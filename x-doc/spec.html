<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><h1 id=x-language-specification>X language specification</h1><p>This is a specification for a language called <strong>x</strong> developed by <a href=https://github.com/bumbread/>bumbread</a>. This document covers all the details about the syntax, semantics and the behaviour of the language. This document does not cover the contents of the standard library.<p>In particular, it will be useful for:<ul><li>Programmers who wish to implement an <strong>x</strong> compiler<li>People who write syntax files for their editors' token highlighters<li>The people interested in the features of the language<li>The <strong>x</strong> language programmers</ul><p>The specification includes examples and the formal definition of the syntax.<p>This document treats all the edge cases objectively, without commenting on what is good and what is bad. The freedom of expression within the language is one of its design principles.<h2 id=1-lexical-syntax>1. Lexical syntax</h2><h3 id=10-possible-ideas-to-be-removed>1.0 Possible ideas (to be removed)</h3><ul><li>Imaginary literals<li>For loops<li>Unsigned, sized types<li>Multiline comments<li>Conditional compilation</ul><h3 id=11-the-notation>1.1. The notation</h3><p>The formal description of the language's syntax is done using a <a href=https://en.wikipedia.org/wiki/Formal_grammar>formal grammar</a> notation. The notation used in this document is similar to <strong>EBNF</strong>, but it has some convenient changes.<p>Every production rule is written as follows.<pre><code class="ebnf language-ebnf">&LTproduction-name> = &LTproduction>
</code></pre><p>The left-hand side contains the name of <strong>production</strong> is written. The names can contain ASCII letters, underscores (<code>_</code>), dashes (<code>-</code>) and digits.<p>A <code>&LTproduction></code> can be a string, for example. Strings are enclosed <code>"</code> (quotation mark) characters. For example, to define the <code>if</code> keyword one could write the following production rule:<pre><code class="ebnf language-ebnf">if-keyword = "if"
</code></pre><p><strong>Alternatives</strong> represent set of several alternative possible productions. Exactly one alternative from that set has to be chosen. Alternatives are separated by the pipe (<code>|</code>) symbol. For example, one can define production rule for a vowel as follows:<pre><code class="ebnf language-ebnf">vowel = "a" | "i" | "u" | "e" | "o"
</code></pre><p>A newline can be put before every <code>|</code> symbol.<pre><code class="ebnf language-ebnf">vowel = "a" 
      | "i"
      | "u"
      | "e"
      | "o"
</code></pre><p><strong>Sequences</strong> represent productions following one after another in order. The sequence looks like two productions following one after another (unlike <strong>EBNF</strong> the comma isn't used in between sequenced productions). For example, rewriting the earlier <code>if</code> keyword example we could get:<pre><code class="ebnf language-ebnf">if-keyword = "i" "f"
</code></pre><p>The <strong>sequence</strong> operation has higher precedence than the <strong>alternative</strong> operation. The production for either string <code>"ab"</code> or <code>"cd"</code> can be defined as follows:<pre><code class="ebnf language-ebnf">random-string = "a" "b"
              | "c" "d"
</code></pre><p>Which will be the same as:<pre><code class="ebnf language-ebnf">random-string = ("a" "b") | ("c" "d")
</code></pre><p>And the same as:<pre><code class="ebnf language-ebnf">random-string = "ab" | "cd"
</code></pre><p>To make a sequence of alternatives instead put a pair of parens <code>()</code>. For example if I want to sequence string <code>"a"</code> with either <code>"0"</code> or <code>"1"</code> I could write:<pre><code class="ebnf language-ebnf">random-string = "a" ("0" | "1")
</code></pre><p>The rule <code>("0" | "1")</code> is called a <strong>group</strong>.<p>Besides the normal groups, this notation also has <strong>repetition</strong> groups that represent the production repeated zero or finitely many times. To repeat a production enclose it in braces (<code>{}</code>). For example one could define a grammar for decimal numbers as follows:<pre><code class="ebnf language-ebnf">decimal-digit = "0" | "1" | "2" | "3" | "4"
              | "5" | "6" | "7" | "8" | "9"

decimal-number = decimal-digit {decimal-digit}
</code></pre><p>The production for <code>decimal-number</code> represents a decimal digit followed by zero or more decimal digits.<p>And <strong>optional</strong> group that marks certain production as being optional. To mark production as optional enclose it with brackets (<code>[]</code>).<p>For strings it's possible to specify an <strong>escape sequence</strong> that will specify unicode codepoint. The syntax has a form of <code>\u+{x}</code>, where <code>x</code> is a hexadecimal character. For example, <code>"\u+30"</code>, <code>"\u+030"</code> and <code>"\u+0030"</code> all mean the same character - <code>"0"</code> (it has unicode codepoint <code>u+0030</code>).<p>Also the <strong>range</strong> operator can be used to specify an alternative of consecutive codepoints. The syntax looks like <code>"character1".."character2"</code>. It takes two single-character strings. The production matches at least one character with codepoints in between <code>"character1"</code> up until and including the codepoint of <code>"character2"</code>.<p>For example, the <code>decimal-digits</code> production from before could be written as:<pre><code class="ebnf language-ebnf">decimal-digit = "\u+30".."\u+39"
</code></pre><p>Or, alternatively:<pre><code class="ebnf language-ebnf">decimal-digit = "0".."9"
</code></pre><p>It is also possible to exclude a digit from a set of alternatives or from a range by using <code>except</code> word. For example to define a rule for all the decimal digits except <code>5</code> it's possible to write the following:<pre><code class="ebnf language-ebnf">digits-but-5: "0".."9" except "5"
</code></pre><p>The formal definition for the grammar using this grammar is therefore:<pre><code class="ebnf language-ebnf">decimal-digit   = "0".."9"
ascii-letter    = "a".."z" | "A".."Z"
identifier-char = ascii-letter | decimal-digits | "-" | "_"
identifier      = identifier-char { identifier-char }

ascii-symbol    = "\u+00".."\u+7f"
backslash       = "\u+5c"
double-quote    = "\u+22"
hex-digit       = "a".."f" | "A".."F" | "0".."9"
hex-number      = hex-digit | {hex-digit}
string          = double-quote (ascii-symbol | backslash "u+" hex-number) double-quote

production-rule = identifier "=" production
production      = alternatives "except" alternatives
alternatives    = sequence   {"|" sequence  }
sequence        = expression {    expression}
expression      = string
                | identifier
                | "(" production ")"
                | "{" production "}"
                | "[" production "]"
</code></pre><h3 id=12-the-source-encoding>1.2. The source encoding</h3><p>The <strong>x</strong> source file must be represented by a sequence of characters encoded using <strong>utf-8</strong> encoding. Other encodings should not be accepted. The utf-8 character codepoints range from <code>0</code> to <code>0x10ffff</code>.<p>The national symbols and other codepoints above ASCII range (<code>"\u+01".."0+7f"</code>) <strong>can only appear inside comments, strings or char literals</strong>.<p>The text is not canonicalized. So any codepoint representing decorated letter is different from two codepoints, one for the letter and one for the diacritics. So <code>だ</code> is treated differently from <code>た</code> followed by the dakuten (<code>u+3099</code>) codepoint. In particular, the string literals may generate different amounts of bytes for each representation of a character.<p>The two characters are different if the codepoints representing them are different. This also implies case-sensitivity.<p>The compiler disallows the NUL (<code>u+0000</code>) character anywhere in the source code except the endmost position, where it is ignored. UTF-8 Byte order mask (<code>0xFEFF</code>) is disallowed anywhere in the source except the very first position, where it is ignored.<p>In the formal syntax, <code>EOF</code> production is used to signify the end of input. The <code>any-char</code> production will be used to denote symbol with any codepoint.<pre><code class="ebnf language-ebnf">any-char = "\u+00".."\u+10ffff"
</code></pre><h3 id=13-lexemes>1.3. Lexemes</h3><p>The source code is represented by sequence of <strong>lexemes</strong>, a.k.a. <strong>tokens</strong>. Lexemes can be one of the following categories:<ul><li><a href=#132-comments><em>Comments</em></a><li><a href=#134-integer-literals><em>Integer literals</em></a><li><a href=#135-floating-point-number-literals><em>Floating-point literals</em></a><li><a href=#136-character-literals><em>Character literals</em></a><li><a href=#137-string-literals><em>String literals</em></a><li><a href=#138-boolean-literals><em>Boolean literals</em></a><li><a href=#139-pointer-literal><em>Pointer literal</em></a><li><a href=#1310-identifiers><em>Identifiers</em></a><li><a href=#1311-special-symbols><em>Special symbols</em></a> (<code>"("</code>, <code>"$"</code>, <code>">="</code>, et cetera)<li><a href=#14-keywords><em>Keywords</em></a></ul><p><strong>x</strong> is a <strong>free-form</strong> programming language. That means that the only role of whitespace and comments is to separate lexemes that otherwise might be tokenized in another manner. The meaning of the program stays the same if each whitespace character is replaced with other whitespace character or if any pair of whitespace characters is replaced by other whitespace character (excluding the whitespace <em>inside</em> the lexemes).<h4 id=131-whitespace>1.3.1. Whitespace</h4><p>Conceptually, whitespace characters are the characters that are "invisible" to the eye.<p>The following characters are considered to be <em>whitespace characters</em>.<ul><li><code>u+0009</code> (horizontal tab)<li><code>u+000a</code> (line feed)<li><code>u+000b</code> (vertical tab)<li><code>u+000c</code> (form feed)<li><code>u+000d</code> (carriage return)<li><code>u+0020</code> (space)</ul><p>Formally,<pre><code class="ebnf language-ebnf">whitespace = "\u+09".."\u+0d" | "\u+20"
</code></pre><p>A particular subset of whitespace is the set of <strong>line terminators</strong>. Line terminators are the characters that are treated by the compiler as being the end of the line. The characters that don't fall into that category are called <strong>line characters</strong>. The following characters are considered to be the line terminators:<ul><li><code>u+000a</code> (line feed)<li><code>u+000b</code> (vertical tab)<li><code>u+000c</code> (form feed)<li><code>u+000d</code> (carriage return)</ul><p>Formal syntax:<pre><code class="ebnf language-ebnf">line-terminator = "\u+0a".."\u+0d"
line-char       = any-char except line-terminator
</code></pre><h4 id=132-comments>1.3.2. Comments</h4><p>The <strong>comments</strong> are special kind of lexeme that are discarded by the compiler. <strong>x</strong> supports three kinds of comments:<ul><li>Line comments<li>Block comments<li>Nesting block comments</ul><p>The line comments start with <code>"#"</code> character that is not part of the string or char literal and ends with any of the line terminator characters, or by the end of file.<p>Formally:<pre><code class="ebnf language-ebnf">lc-first-char  = any-char  except "#" | "*" | line-terminator
line-comment   = "#" lc-first-char {line-char} (line-terminator | EOF)
</code></pre><p>The <strong>block comments</strong> are comments that have both start marker and the end marker. The block comments start with <code>##</code> and end with <code>##</code>. Block comments can not contain the string <code>##</code>. As a consequence, the block comments do not nest.<pre><code class="ebnf language-ebnf">bc-marker     = "##"
bc-char       = (any-char except "#") | ("#" (any-char except "#"))
block-comment = bc-marker {bc-char} bc-marker
</code></pre><p>In order to go around the limitation of no-nesting use <strong>nesting block comments</strong>. Instead of using single marker for the start and the end these comments use symmetric opening marker (<code>#*</code>) and ending marker (<code>*#</code>).<pre><code class="ebnf language-ebnf">nbc-start     = "#*"
nbc-end       = "*#"
nbc-char      = (any-char except "*") | ("*" (any-char except "#")) | nb-comment
nb-comment    = nbc-start {nbc-char} nbc-end
</code></pre><p>Also within line comments <code>##</code> and <code>#*</code> has no special meaning. Within block comments <code>#</code> and <code>#*</code> have no special meaning. And within the nested block comments, <code>#</code> and <code>##</code> have no special meaning.<p>The self-described examples of comments, either valid or invalid:<pre><code class="x language-x"># Line comment can contain ## and #*
# Комментарий на русском
#nospaces

outside

#*Anything starting with ## is a block comment*#

outside

## Inside comment ## outside comment ## inside comment ##

outside

### Block comment's text starts with '#' symbol. ##

outside

#*#*Error: the nesting block comment is not closed*# still inside

outside

## #* the nested block comments have no effect ## inside block comments. *#
</code></pre><p>The line comments will also be used in the following examples of the <strong>x</strong> code to describe them.<h4 id=133-escape-sequences>1.3.3. Escape sequences</h4><p>In <a href=#136-character-literals><em>character literals</em></a> and in <a href=#137-string-literals><em>string literals</em></a>, apart from the raw unicode characters, the user can input a special sequence of characters that would map to a single character.<p>The list of escape sequences:<ul><li><code>\t</code> - horizontal tab symbol, maps to <code>\u+09</code><li><code>\n</code> - line feed symbol, maps to <code>\u+0a</code><li><code>\"</code> - the quotation mark, maps to <code>\u+22</code><li><code>\'</code> - the apostrophe symbol, maps to <code>\u+27</code><li><code>\\</code> - the backslash symbol, maps to <code>\u+5c</code><li><code>\u{x}</code> - the unicode codepoint (up to 6 characters)</ul><p>All other sequences starting with backslash are invalid. The compiler throws an error if it encounters such a sequence.<p>The <code>\'</code> and <code>\"</code> backslash sequences are available in either string literals or character literals. The compiler does not treat e.g. <code>\'</code> inside a string literal as an error.<p>Note that the unicode escape sequence maps to the code specified after <code>u</code>. Some examples:<pre><code class="x language-x">\u0       # maps to u+0000
\u00      # still maps to u+0000
\u000     # still maps to u+0000
\u0000    # still maps to u+0000
\u00000   # still maps to u+0000
\u000000  # still maps to u+0000
\u0000000 # counts as 2 characters: u+0000 followed by u+0030
\u110000  # invalid, the code point is greater than u+10ffff
</code></pre><h4 id=134-integer-literals>1.3.4. Integer literals</h4><p>The integer literals represent constant positive whole numeric values. The values can be specified in a variety of flavors: binary (bin) literals, octal (oct) literals, decimal (dec) literals and finally hexadecimal (hex) literals.<p>The literals in base other than 10 (and <em>optionally</em> in base 10) can be prefixed with a special prefix.<ul><li><code>0b</code> and <code>0B</code> are the prefixes for <em>binary</em> literals.<li><code>0o</code> and <code>0O</code> (zero followed by capital o) are the prefixes for <em>octal</em> literals.<li><code>0d</code> and <code>0D</code> are the prefixes for <em>decimal</em> literals.<li><code>0x</code> and <code>0X</code> are the prefixes for <em>hexadecimal</em> literals.</ul><p>The integer literal can optionally contain underscores for visual clarity, e.g. one million can be written as <code>1_000_000</code> or like <code>100_0000</code>. The integer literal can not start with an underscore. The underscore can, however appear anywhere after the first digit or after the prefix. So <code>0b_0</code> is valid. Since underscores are treated as digits, <code>0b_</code> is a valid integer literal as well.<p>The underscores are ignored. If the only digit after the prefix is the underscore, e.g. in the case <code>0b_</code>, then the value of the literal is <code>0</code>.<p>Whatever the base is, the final parsed value has to be no greater than <code>922_3372_0368_5477_5808</code> (<code>0x80000000_00000000</code> in hex). If the specified value is greater, the compiler produces an error.<p>Due to how the complement of two works, there's a special restriction on the literal with the value <code>922_3372_0368_5477_5808</code>. This literal can only appear as a direct operand to a unary <code>-</code> operation, where it is statically converted to the value of <code>-922_3372_0368_5477_5808</code>. Otherwise no signed 64-bit integer can have a value of <code>922_3372_0368_5477_5808</code> or bigger.<p>In hex literals, the case of characters is ignored. <code>0xf</code> and <code>0xF</code> mean the same thing.<p>The formal syntax for integer literals:<pre><code class="ebnf language-ebnf">bin-digit   = "0".."1" | "_"
bin-prefix  = "0b" | "0b"
bin-literal = bin-prefix {bin-digit}

oct-digit   = "0".."7" | "_"
oct-prefix  = "0o" | "0O"
oct-literal = oct-prefix {oct-digit}

dec-start   = "0".."9"
dec-digit   = "0".."9" | "_"
dec-prefix  = "0d" | "0D"
dec-literal = (dec-prefix | dec-start) {dec-digit}

hex-digit   = "0".."9" | "a".."f" | "A".."F" | "_"
hex-prefix  = "0x" | "0X"
hex-literal = hex-prefix {hex-digit}

int-literal = bin-literal | oct-literal | dec-literal | hex-literal
</code></pre><p>Here's an example of valid and invalid integer literals<pre><code class="x language-x">0                      # valid, parsed as 0
00                     # valid, parsed as 0
100_0000               # valid, parsed as 1000000
0d_1_000_0             # valid, parsed as 10000
0_                     # valid, parsed as 0
0d_                    # valid, parsed as 0
-9223372036854775808   # valid, parsed as-is
-(9223372036854775808) # invalid, 9223372036854775808 has to be a direct operand to a unary minus
0d1F                   # invalid, uses hexadecimal digits in decimal value
_1000                  # invalid, actually parsed as identifier lexeme
0_d1000                # invalid, underscore is not allowed to break the prefix

</code></pre><h4 id=135-floating-point-number-literals>1.3.5. Floating-point number literals</h4><p>The fractional and decimal numbers are stored according to "IEEE754 standard for floating point arithmetic". The language uses the 64-bit values to represent the values.<p>The floating point literals are <strong>required</strong> to contain the <code>"."</code> (dot) symbol. In general, the floating point literal can be represented as<pre><code class="x language-x">[prefix] &LTwhole digits> . &LTfractional digits> [(E|P) [+|-] &LTexponent digits>]
</code></pre><p>It is <strong>required</strong> to have at least one whole digit, one fractional digit, and if the exponent part exists, one exponent digit. This requirement is not satisfied, as in <code>1.e+1</code>, the compiler throws an error. The required digit can be <code>_</code> if it's not the first digit of an unprefixed literal. Thus, <code>0_._e+_</code> is a valid floating point literal.<p>The compiler only supports two flavors of the floating-point numbers: decimal floating point numbers, and hex floating-point numbers. The hex floating-point literals are prefixed with <code>0x</code> or <code>0X</code>, the decimal floating-point literals are <em>optionally</em> prefixed with <code>0d</code> or <code>0D</code>.<p>In case of decimal floating point numbers, if the fractional digits are followed by <code>"e"</code> or <code>"E"</code> symbol, the exponent digits specify decimal exponent, where the value of the literal is in the form:<pre><code class="x language-x">value = (whole.fraction) * 10^exponent
</code></pre><p>Note the <code>10</code> in the base of the exponent.<p>In case of binary floating-point numbers, if the fractional digits are followed by <code>"p"</code> or <code>"P"</code>, the exponent digits specify binary exponent. And the value of the literal is in the form:<pre><code class="x language-x">value = (whole.fraction) * 2^exponent
</code></pre><p>Note the <code>2</code> in the base of the exponent.<p>If the value of a floating-point number is in the subnormal range, or exceeds the 64-bit floating-point maximum value, then compiler throws an error. If a floating point number is not exactly representable it is rounded to the nearest exactly-representable even number.<p>There are two special floating point literals: <code>nan</code> and <code>inf</code>. The first one represents errorneus value of NaN, according to IEEE754 standard, and the second one represents the value of positive infinity. Those two literals are case-sensitive.<p>The formal syntax is as follows:<pre><code class="ebnf language-ebnf">dec-prefix = "0d" | "0D"
dec-start  = "0".."9"
dec-digit  = "0".."9" | "_"
dec-whole  = (dec-prefix | dec-start) {dec-digit}
dec-fract  = {dec-digit}
dec-exp    = {dec-digit}
dec-float  = dec-whole "." dec-fract [("e" | "E") ["+" | "-"] dec-exp]

hex-prefix = "0x" | "0X"
hex-digit  = "0".."9" | "a".."f" | "A".."F" | "_"
hex-whole  = hex-prefix {hex-digit}
hex-fract  = {hex-digit}
hex-exp    = {hex-digit}
hex-float  = hex-whole "." hex-fract [("p" | "P") ["+"|"-"] hex-exp]

float-literal = dec-float | hex-float | "nan" | "inf"
</code></pre><p>Some examples:<pre><code class="x language-x">2.0E+1   # valid, parsed as 20.0
0d2.0E-1 # valid, parsed as (2.0 * 2^-1), or 1.0
2._      # valid, parsed as 2.0
0x_._e+_ # valid, parsed as 0.0
2E+1     # invalid, doesn't contain "." symbol
2.0p+1   # invalid, binary exponent in decimal value
0x2.0e-1 # invalid, decimal exponent in hex value
</code></pre><h4 id=136-character-literals>1.3.6. Character literals</h4><p>Character literals represent integer values of the unicode codepoints. They can be given either by giving character directly, or by providing an escape sequence.<pre><code class="ebnf language-ebnf">apostrophe  = "\u+2d"
backslash   = "\u+5c"
char-symbol = any-char except apostrophe | backslash

char-literal = apostrophe (char-symbol | escape-sequence) apostrophe
</code></pre><p>Some examples of character literals:<pre><code class="x language-x">'
'         # valid, contains newline character

'a'       # valid, maps to u+61
'я'       # valid, contains a Unicode character
'\''      # valid, maps to "'" (apostrophe) character
'"'       # valid, maps to '"' (quote mark) character
'\"'      # also valid, maps to '"' (quote mark) character
'\'       # invalid, the character literal isn't closed
''        # invalid, the character literal is empty
'\u11000' # invalid, the literal specifies character out of the range of Unicode codepoints
</code></pre><h4 id=137-string-literals>1.3.7. String literals</h4><p>String literals represent Unicode strings of text. The strings can contain any Unicode characters (including some control characters, like line feed)<pre><code class="ebnf language-ebnf">quote-mark  = "\u+22"
backslash   = "\u+5c"
str-symbol  = any-char except quote-mark | backslash

str-literal = quote-mark {str-symbol | escape-sequence} quote-mark
</code></pre><p>The examples of valid and invalid strings:<pre><code class="x language-x">"abcdef" # valid
"абвгед" # valid

"
hey
"        # valid, contains "\nhey\n"

"#"      # valid, contains the "#" character
</code></pre><h4 id=138-boolean-literals>1.3.8. Boolean literals</h4><p>There are two boolean literals: <code>true</code> and <code>false</code>.<pre><code class="ebnf language-ebnf">bool-literal = "true" | "false"
</code></pre><h4 id=139-pointer-literal>1.3.9. Pointer literal</h4><p>There is only one pointer literal: <code>null</code>.<pre><code class="ebnf language-ebnf">ptr-literal = "nil"
</code></pre><h4 id=1310-identifiers>1.3.10. Identifiers</h4><p>Identifiers represent user-defined names and <em>keywords</em>. The identifiers may only contain ASCII letters, underscores and digits. However identifiers are not allowed to start with a digit.<p>The formal syntax:<pre><code class="ebnf language-ebnf">identifier-start = "_" | "a".."z" | "A".."Z"
identifier-char  = "_" | "a".."z" | "A".."Z" | "0".."9"
identifier       = identifier-start {identifier-char}
</code></pre><p>Some valid and invalid identifiers:<pre><code class="x language-x">cat    # valid
_cat__ # valid
d012   # valid
0d10   # invalid, starts with digit
a\ts   # invalid, can not contain backslash
жаба   # invalid, can not contain non-ascii characters
</code></pre><h4 id=1311-special-symbols>1.3.11 Special symbols</h4><p>A special set of character sequences is used as single lexemes for some operators. For example <code>+=</code> is not the plus lexeme followed by the equals lexeme, rather, it is a single lexeme. The compiler must match the longest operator from this sequence before advancing parsing to the next lexeme.<pre><code class="x language-x">+   +=   ~   ~=   $   <    &LT-   (    )
-   -=   |   |=   @   >    ->   [    ]
*   *=   &   &=   !   <=   ,    {    }
/   /=   <<  <<=  ?   >=   .    ;
%   %=   >>  >>=  ==  !=   :    ..
</code></pre><h3 id=14-keywords>1.4 Keywords</h3><p>Keywords are special types of identifiers whose usage is reserved for special occasions. User can not declare a variable or a type with the keyword name.<p>The list of keywords and their meaning is listed before<table><thead><tr><th>keyword<th>meaning<tbody><tr><td><code>and</code><td>boolean and operation<tr><td><code>or</code><td>boolean or operation<tr><td><code>xor</code><td>boolean xor operation<tr><td><code>iff</code><td>boolean equivalence operation<tr><td><code>implies</code><td>boolean implication operation<tr><td><code>not</code><td>boolean negation operation<tr><td><code>sizeof</code><td>sizeof operation<tr><td><code>typeof</code><td>typeof operation<tr><td><code>offsetof</code><td>offsetof operation<tr><td><code>if</code><td><strong>if</strong> statement's starting lexeme<tr><td><code>else</code><td>else branch of the <strong>if</strong> statement<tr><td><code>while</code><td><strong>while</strong> statement's starting lexeme<tr><td><code>do</code><td><strong>do</strong> starting lexeme of inline statement block<tr><td><code>repeat</code><td>starting lexeme of <strong>repeat-until</strong> statement<tr><td><code>until</code><td><strong>until</strong> part of the repeat until statement<tr><td><code>try</code><td><strong>try</strong> starting lexeme of the try-catch block<tr><td><code>catch</code><td><strong>catch</strong> in the try-catch block<tr><td><code>let</code><td>variable declaration starting lexeme<tr><td><code>type</code><td>type declaration starting lexeme<tr><td><code>func</code><td>func declaration starting lexeme and func type name<tr><td><code>meth</code><td>method declaration inside structs<tr><td><code>this</code><td>encapsulated struct pointer<tr><td><code>operator</code><td>operator declaration inside structs<tr><td><code>struct</code><td><strong>struct</strong> declaration starting lexeme and struct type name<tr><td><code>enum</code><td><strong>enum</strong> declaration starting lexeme and enum type name<tr><td><code>union</code><td><strong>union</strong> declaration starting lexeme and union type name<tr><td><code>print</code><td>print statement's starting lexeme<tr><td><code>assert</code><td>assert statement's starting lexeme<tr><td><code>break</code><td>break statement<tr><td><code>continue</code><td>continue statement<tr><td><code>return</code><td>return statement<tr><td><code>throw</code><td>throw statement<tr><td><code>import</code><td>import file<tr><td><code>namespace</code><td>namespace scope</table><p>Note that <code>nan</code>, <code>inf</code>, <code>false</code>, <code>true</code> and <code>nil</code> are not keywords. They are more like pre-declared identifiers.<p>Another name that one can not use when naming an identifier is <code>_</code> (single underscore). This identifier has special meaning. Note that <code>_</code> is not a keyword either.<h2 id=2-code-structure>2. Code structure</h2><p>This section covers the syntactical structure of the <strong>x</strong> programs. This section only covers the syntax of the language without explaining their semantics.<h3 id=21-expressions>2.1. Expressions</h3><h4 id=211-operators>2.1.1. Operators</h4><p>The unary operators of the language are:<table><thead><tr><th>Sign<th>Operation name<tbody><tr><td><code>$</code><td>Addressof<tr><td><code>@</code><td>Dereference<tr><td><code>-</code><td>Negate<tr><td><code>~</code><td>Bitwise negation<tr><td><code>not</code><td>Logical negation<tr><td><code>[N]</code><td>Subscript<tr><td><code>[N:M]</code><td>Subslice<tr><td><code>(...)</code><td>Function call</table><p>The binary operations of the language:<table><thead><tr><th>Sign<th>Operation name<tbody><tr><td><code>+</code><td>Sum<tr><td><code>-</code><td>Difference<tr><td><code>*</code><td>Product<tr><td><code>/</code><td>Divide<tr><td><code>%</code><td>Modulo<tr><td><code>&</code><td>Bitwise and<tr><td><code>|</code><td>Bitwise or<tr><td><code>~</code><td>Bitwise not<tr><td><code><<</code><td>Shift up<tr><td><code>>></code><td>Shift down<tr><td><code>></code><td>Greater<tr><td><code><</code><td>Less<tr><td><code>>=</code><td>No-less<tr><td><code><=</code><td>No-Greater<tr><td><code>==</code><td>Equal<tr><td><code>!=</code><td>Not equal<tr><td><code>:</code><td>Cast<tr><td><code>::</code><td>Transmute<tr><td><code>and</code><td>Logical and<tr><td><code>or</code><td>Logical or<tr><td><code>xor</code><td>Logical xor<tr><td><code>implies</code><td>Logical implication<tr><td><code>iff</code><td>Logical equivalence</table><p>And the following operators are considered to be assignment operators:<table><thead><tr><th>Sign<th>Operation name<tbody><tr><td><code>=</code><td>Assign<tr><td><code>+=</code><td>Add<tr><td><code>-=</code><td>Subtract<tr><td><code>*=</code><td>Multiply by<tr><td><code>/=</code><td>Divide by<tr><td><code>%=</code><td>Assign remainder<tr><td><code>&=</code><td>And with<tr><td><code>|=</code><td>Or with<tr><td><code>~=</code><td>Xor with<tr><td><code>>>=</code><td>Shift down<tr><td><code><<=</code><td>Shift up</table><h4 id=212-operator-precedence>2.1.2. Operator precedence</h4><p>Operator precedence defined as follows. Every unary operator has higher precedence than any binary operator and any ternary operator. And for every unary operator, postfix unary operators have higher precedence than prefix unary operators.<p>According to these rules the following equalities hold for any suitable operands:<pre><code class="x language-x">@x$   ==   @(x$)   # dereferenced value of address of x
@f(x) ==   @(f(x)) # dereference return value of function f called with parameter x
~x$   ==   ~(x$)   # bitwise negation of address of x
-a[2] ==   -(a[2]) # negating second element of a slice
</code></pre><p>The unary operators are evaluated inside-out, starting from where the expression occurs. So <code>-~@x</code> is the same as <code>-(~(@x))</code>. Therefore the precision for all unary operators is clearly defined using just two rules.<p>The precedence table for the binary operators follows. Higher precedence level means higher precedence, i.e. the "binding" of those operators is stronger.<table><thead><tr><th>Precedence<th>Group name<th>Operators<tbody><tr><td>7<td>Product-like<td><code>&</code>, <code><<</code>, <code>>></code>,<code>*</code>, <code>/</code>, <code>%</code><tr><td>6<td>Sum-like<td><code>|</code>, <code>~</code>,<code>+</code>, <code>-</code><tr><td>5<td>Relational<td><code>==</code>, <code>!=</code>, <code>></code>, <code><</code>, <code>>=</code>, <code><=</code><tr><td>4<td>Boolean and<td><code>and</code><tr><td>3<td>Boolean or-like<td><code>or</code>,<code>xor</code><tr><td>2<td>Boolean relational<td><code>iff</code>, <code>implies</code><tr><td>1<td>Type conversions<td><code>:</code>, <code>::</code><tr><td>0<td>Assignment<td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&=</code>, <code>|=</code>, <code>~=</code>, <code>>>=</code>, <code><<=</code></table><h4 id=213-expressions-syntax>2.1.3. Expressions syntax</h4><p>In the previous sections operators in the language were informally introduced. Now the concrete syntax for expressions in <strong>x</strong> is presented.<pre><code class="ebnf language-ebnf">literal      = int-literal 
             | float-literal
             | char-literal
             | bool-literal
             | ptr-literal
             | string-literal
             | identifier

call-params  = "(" [expression { "," expression }] ")"
subscript    = "[" (expression | ([expression] ":" [expression]) ) "]"

postfix-op   = "$" | call-params | subscript
prefix-op    = "-" | "~" | "@"

op-prod      = "&" | "<<" | ">>" | "*" | "/" | "%"
op-sum       = "|" | "~" | "+" | "-"
op-rel       = "==" | "!=" | ">" | "<" | ">=" | "<="
op-b-and     = "and"
op-b-or      = "or" | "xor"
op-b-rel     = "iff" | "implies"
op-type      = ":" | "::"
op-ass       = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "~=" | "&=" | "|="

expr-lit     = literal
             | "(" expression ")"

expr-postfix = expr-lit { postfix-op }
expr-prefix  = expr-postfix
             | prefix-op expr-prefix

expr-prod    = expr-prefix { op-prod  expr-prefix }
expr-sum     = expr-prod   { op-sum   expr-prod   }
expr-rel     = expr-sum    { op-rel   expr-sum    }
expr-b-and   = expr-rel    { op-b-and expr-rel    }
expr-b-or    = expr-b-and  { op-b-or  expr-b-and  }
expr-b-rel   = expr-b-or   { op-b-rel expr-b-or   }
expr-type    = expr-b-rel  { op-type  expr-b-rel  }
expr-ass     = expr-type   { op-ass   expr-type   }

expression   = expr-ass
</code></pre><p>Some examples and how they are parsed:<pre><code class="x language-x">2 + 2 * 2              # 2 + (2*2)
1 : int + 2            # (1:int) + 2
1 + 2 : int            # (1+2): int
1>2 and 2+2==4 or 3!=2 # ((1>2) and ((2+2)==4)) or (3 != 2)
2+-1                   # 2+(-1)
a>b implies a/b != 0   # (a>b) implies ((a/b)!=0)
a = 3 : int            # a = (3: int)
$a(3)*4                # ($(a(3)))*4
</code></pre><h3 id=22-types>2.2. Types</h3><h4 id=211-primitive-types>2.1.1. Primitive types</h4><p><strong>x</strong> supports the following basic types: <code>bool</code>, <code>int</code>, <code>float</code>, <code>ptr</code>. Every one of the basic types has it's own semantics, and each is defined for several sizes.<pre><code class="ebnf language-ebnf">size-spec  = "(" int-literal ")"

bool-type  = "bool"   [ size-spec ]
int-type   = "int"    [ size-spec ]
float-type = "float"  [ size-spec ]
ptr-type   = "ptr"    [ size-spec ]

basic-type = bool-type
           | int-type
           | float-type
           | ptr-type

prim-type = basic-type | identifier
</code></pre><p>Every primitive type expects number of bytes used for the storage. The size has to be a constant <a href=#134-integer-literal>integer literal</a>, it can not contain expressions and the value of the literal has to be a power of two. If invalid literal is input, the compiler throws an error.<p>The values for these sizes above 8 may be supported by the compiler, but only the sizes of 8 and below are <em>guaranteed</em> by the compiler to be supported.<p>If the size wasn't input the following defaults apply:<pre><code class="x language-x">bool  = bool(1)
int   = int(8)
float = float(8)
ptr   = ptr(8)
</code></pre><p>Primitive type can be either one of the basic types or an alias for type.<h4 id=212-pointer-types>2.1.2. Pointer types</h4><p>Pointers represent addresses of variables in memory. Typed pointers have the syntax of a type followed by a <code>$</code> sign.<pre><code class="ebnf language-ebnf">ptr-type = simple-type "$" 
</code></pre><p>Examples:<pre><code class="x language-x">int$    # pointer to int
int$$   # pointer to pointer to int
</code></pre><h4 id=213-slice-types>2.1.3. Slice types</h4><p>The slices represent a particular chunk of memory. It can be thought of as an array of objects. The name <em>slice</em> is due to the fact that their focus isn't on the grouping of objects, but rather on the memory.<pre><code class="ebnf language-ebnf">slice-type = simple-type "[" "]"
</code></pre><p>Some examples of slice types:<pre><code class="x language-x">byte[]    # slice of bytes
int$[]    # slice of pointers to int
entity[]$ # pointer to slice of 'entity'
</code></pre><h4 id=214-function-types>2.1.4. Function types</h4><p>The function types represent code that can execute with given <em>parameters</em> and <em>return</em> some result.<p>The type is indicated by a keyword <code>func</code> followed by parameter lists in parens <code>()</code> and then return type is indicated after the right arrow (<code>-></code>).<p>In <strong>x</strong> the parameter declaration syntax is flexible, because of two reasons. First, <strong>x</strong> allows two different types of separators that programmer can use according to their taste. Secondly, parameter declarations can be grouped by type.<pre><code class="ebnf language-ebnf">sep          = "," | ";"

iden-list    = identifier {sep identifier}
func-param   = iden-list ":" type
func-params  = func-param {sep func-param}

func-mapping = "(" [func-params] ")" ["->" simple-type]
func-type    = "func" func-mapping
</code></pre><p>Some examples of function types:<pre><code class="x language-x"># function taking no parameters and returning nothing
func()

# function taking no parameters and returning an int
func()->int

# function taking two first int parameter and second float parameter
# and not returning a value
func(a: int, b: float)

# same as above, uses semicolon for separator
func(a: int; b: float)

# function taking one parameter of type
#   (pointer to function taking int, returning an int)
# and returning an int
func(a: (func(a: int)->int)$ )->int

# invalid, parameter can't be a function type
func(a: func())->int

# function taking 3 ints and 1 float, and 1 bool
# note the different separators
func(x,y;z:int, a:float; b: bool)

# pointer has higher precedence in the return type
# so the following function returns pointer to int
func()->int$

# and this is a pointer to a function returning int
(func()->int)$
</code></pre><h4 id=215-struct-types>2.1.5. Struct types</h4><p><em>Struct</em> types represent groups of values stored together as a single unit of data. In pascal, also known as the <em>records</em>.<p>In <strong>x</strong> struct types, can also contain <em>functions</em> and <em>methods</em>.<p>Declarations in struct fields are be <em>separated</em> by either <code>","</code> (comma) or <code>";"</code> (semicolon). The function and method declarations inside structs may not be followed by the separator. All <em>field</em> declarations, except if it is the last in the struct to be terminated by either <code>","</code> or <code>";"</code>.<p>At least one declaration is required by syntax in structs.<p>Syntax:<pre><code class="ebnf language-ebnf">sep          = ";" | ","

iden-list    = identifier {sep identifier}
struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier func-mapping "{" stmt-list "}" [sep]

struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl

struct-body  = "{" struct-decls "}"
struct-type  = "struct" struct-body
</code></pre><p>Examples:<pre><code class="x language-x"># classic C-like separation of fields separated by ';'
struct {
  a: int;
  b: float;
}

# Inline style declaration with ',' separator
struct {a:int, b:float}

# Same as above, with trailing comma
struct {a:int, b:float,}

# Struct with packed decls, function and method
struct {
  x,y;z: int;
  c:float,

  func add(a,b: int)->int {
    return a+b;
  }

  meth neg() {
    x = -x;
    y = -y;
    z = -z;
  };
}

# valid, structs can contain pointer to functions as fields
struct {
  f: (func()->int)$;
}

# invalid, structs can not contain function fields
struct {
  f: func()->int;
}

# invalid, structs have to have at least one decl
struct {}
</code></pre><h4 id=216-union-types>2.1.6. Union types</h4><p><strong>TODO</strong><h4 id=217-enum-types>2.1.7. Enum types</h4><p><strong>TODO</strong><h4 id=218-type-syntax>2.1.8. Type syntax</h4><p>The complete syntax for the types in <strong>X</strong> is presented below. All of the left-recursions have been removed.<pre><code class="ebnf language-ebnf">size-spec  = "(" int-literal ")"

bool-type  = "bool"   [ size-spec ]
int-type   = "int"    [ size-spec ]
float-type = "float"  [ size-spec ]
ptr-type   = "ptr"    [ size-spec ]
prim-type  = bool-type | int-type | float-type | ptr-type | identifier

sep          = ";" | ","
iden-list    = identifier {sep identifier}

func-param   = iden-list ":" type
func-params  = func-param {sep func-param}
func-mapping = "(" [func-params] ")" ["->" simple-type]
func-type    = "func" func-mapping

struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier func-mapping "{" stmt-list "}" [sep]
struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl
struct-body  = "{" struct-decls "}"
struct-type  = "struct" struct-body

base-type    = prim-type| struct-type | "(" type ")" 
simple-type  = base-type {"$" | "[]"}

type         = simple-type | func-type {"$" | "[]"}
</code></pre><h3 id=23-statements>2.3. Statements</h3><h4 id=331-expression-statements>3.3.1. Expression statements</h4><p>Expression statements are simply expressions terminated by <code>;</code>.<pre><code class="ebnf language-ebnf">expr-stmt = expr ";"
</code></pre><h4 id=232-variable-declarations>2.3.2. Variable declarations</h4><p>Variable declarations are used to introduce variables.<pre><code class="ebnf language-ebnf">name-list = identifier ["," identifier]
let-decl  = "let" name-list [":" type] ["=" expr] ";"
</code></pre><p>If <code>name-list</code> has more than one name then declaration can not have an initializer.<p>If <code>type</code> was not specified, the initialization is <em>required</em>.<p>Examples of syntactically valid variable declarations:<pre><code class="x language-x">let x,y,z: float;
let pEntityID: int$ = null;
let func_ii: (func(a,b:int)->int)$ = max_ii$;
let myint = 3;
let is_bad = false;
</code></pre><h4 id=233-function-declarations>2.3.3. Function declarations</h4><p>Function declarations are used to declare functions. The functions can be declared anywhere in the code, and the function declarations are <em>required</em> to have a body.<p>At the end of the declaration the semicolon is optional.<pre><code class="ebnf language-ebnf">func-decl = "func" identifier func-mapping "{" stmt-list "}" [";"]
</code></pre><p>The examples of syntactically valid function declarations:<pre><code class="x language-x">func max_ii(a,b: int)->int {
  if a>b do return a;
  else return b;
}

func max_s(s: int[])->int {
  let max: int = s[0];
  let i: int = 0;
  while i&LTs.length {
    if s[i] > max do max = s[i];
    i += 1;
  }
}
</code></pre><h4 id=234-type-declarations>2.3.4. Type declarations</h4><p>Type declarations are used to declare types. The syntax is somewhat inspired by pascal.<pre><code class="ebnf language-ebnf">type-decl = "type" identifier "=" type ";"
</code></pre><p>Examples of type declarations:<pre><code class="x language-x">type handle = ptr;

type player = struct {
  x,y,z: float;

  meth move: () {
    this.x += 1;
    this.y += 1;
    this.z += 1;
  }
};

type vec2 = struct {
  x,y: float;

  func make(a,b: float)->vec2 {
    let result: vec2;
    result.x = a;
    result.y = b;
    return result;
  }

  meth negate() {
    this.x = -this.x;
    this.y = -this.y;
  }
};
</code></pre><h4 id=235-if-statement>2.3.5. If statement</h4><p>If statement lets conditionally execute some code, depending on some part of the state of the program.<pre><code class="ebnf language-ebnf">stmt-body = "{" stmt-list "}" | "do" stmt | ";"
if-stmt    = "if" expr stmt-body
             [ "else" (stmt-body | stmt) ]
</code></pre><p>Unlike C-like languages, <strong>x</strong> doesn't require parenthesis around expressions. As a tradeoff the brackets around the statement list are required, unless <code>do</code> keyword is used.<p>If several <em>inline if</em> statements are chained, one inside another, the <code>else</code> block becomes part of the inner-most <code>if</code> statement.<p>Here's a list of examples:<pre><code class="x language-x">if a>10 {
  print "karamba!";
}

if a>10 do print "karamba!";

if a>10 do { print "karamba"; }

if a>10 do
   if b>10 do
      if c>10 do print "ha!"
      else print "hey :(";
   else print "ok";
else print "ok";

if f();
</code></pre><h4 id=336-while-statement>3.3.6. While statement</h4><p>While statements let the program repeat execution of a certain statement block <em>zero or more times</em> based on the program's state.<p>The syntax of while loops is the following:<pre><code class="ebnf language-ebnf">stmt-body = "{" stmt-list "}" | "do" stmt | ";"
while-stmt = "while" expr stmt-body
</code></pre><p>Examples:<pre><code class="x language-x">while a&LT10 {
  print a;
  a += 1;
}

while a&LT10 do a+=1;

while state && f(state$);
</code></pre><h4 id=338-repeat-statement>3.3.8. Repeat statement</h4><p>Repeat statements let program repeat execution of a certain statement block <em>one or more times</em>.<p>The syntax for repeat statements is the following:<pre><code class="ebnf language-ebnf">repeat-stmt = "repeat" stmt-list "until" expr ";"
</code></pre><p>Examples:<pre><code class="x language-x">repeat
  a += 3;
  print a;
until a>=100;

repeat {
  a += 1;
  print a;
} until a>=100;

repeat a+=1; until a>=100;
</code></pre><h4 id=337-flow-control-statements>3.3.7. Flow control statements</h4><p>The <code>break</code> statements jumps out of any loop. Thus it can be used only within loops.<p>The <code>continue</code> statement jumps to the code that evaluates the condition thereby advancing the loop to one more execution. This statement also can only be used within loops.<p>The <code>return</code> statement returns an expression from the function scope. And jumps back to the code that called the function. The <code>return</code> statement can only be used within function and method bodies.<pre><code class="ebnf language-ebnf">break-stmt    = "break" ";"
continue-stmt = "continue" ";"
return-stmt   = "return" [expr] ";"
</code></pre><p>Example:<pre><code class="x language-x">func min(s: int[])->int {
  let m: int = s[0];
  let i: int = 1;
  while i&LTs.len do if s[i]>m {
    m = s[i];
    break;
  }
  return m;
}

func nop() {
  return;
}
</code></pre><h4 id=338-block-statements>3.3.8. Block statements</h4><p>Block statements let you group several statements into one and introduce a <em>scope</em>.<pre><code class="ebnf language-ebnf">stmt-list  = stmt [stmt]
block-stmt = "{" stmt-list "}"
</code></pre><p>Example:<pre><code class="x language-x">{
  let x: int = 0;
  let y: int = 2;
  {
    # x and y are accessible here
    if x>y do print "a";

    {
      # x and y are still accessible
      let z: int = x+y;
      # and now z is also accessible
      if z>x do print z;
    }

    # z is inaccessible anymore, but x and y are
    print x-y;
  }


}
</code></pre><h3 id=24-program-structure>2.4. Program structure</h3><p>The source code structure of <strong>X</strong> represets a list of statements. Whenever the <strong>X</strong> program is compiled and then executed, conceptually the execution starts from the very first statement of the program. Unlike most other procedural and object-oriented programming languages, <strong>X</strong> does not require an execution entry point.<p>Therefore<pre><code class="x language-x">let x: int = 3;
while x < 10 {
  x += 1;
}

print x;
</code></pre><p>Is a valid <strong>X</strong> program.