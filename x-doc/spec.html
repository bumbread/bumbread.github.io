<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><h1 id=x-language-specification>X language specification</h1><p>This is a specification for a language called <strong>x</strong> developed by <a href=https://github.com/bumbread/>bumbread</a>. This document covers all the details about the syntax, semantics and the behaviour of the language. This document does not cover the contents of the standard library.<p>In particular, it will be useful for:<ul><li>Programmers who wish to implement an <strong>x</strong> compiler<li>People who write syntax files for their editors' token highlighters<li>The people interested in the features of the language<li>The <strong>x</strong> language programmers</ul><p>The specification includes examples and the formal definition of the syntax.<p>This document treats all the edge cases objectively, without commenting on what is good and what is bad. The freedom of expression within the language is one of its design principles.<h2 id=1-lexical-syntax>1. Lexical syntax</h2><h3 id=10-possible-ideas-to-be-removed>1.0 Possible ideas (to be removed)</h3><ul><li>Imaginary literals<li>For loops<li>Unsigned, sized types<li>Multiline comments<li>Conditional compilation</ul><h3 id=11-the-notation>1.1. The notation</h3><p>The formal description of the language's syntax is done using a <a href=https://en.wikipedia.org/wiki/Formal_grammar>formal grammar</a> notation. The notation used in this document is similar to <strong>EBNF</strong>, but it has some convenient changes.<p>Every production rule is written as follows.<pre><code class="ebnf language-ebnf">&LTproduction-name> = &LTproduction>
</code></pre><p>The left-hand side contains the name of <strong>production</strong> is written. The names can contain ASCII letters, underscores (<code>_</code>), dashes (<code>-</code>) and digits.<p>A <code>&LTproduction></code> can be a string, for example. Strings are enclosed <code>"</code> (quotation mark) characters. For example, to define the <code>if</code> keyword one could write the following production rule:<pre><code class="ebnf language-ebnf">if-keyword = "if"
</code></pre><p><strong>Alternatives</strong> represent set of several alternative possible productions. Exactly one alternative from that set has to be chosen. Alternatives are separated by the pipe (<code>|</code>) symbol. For example, one can define production rule for a vowel as follows:<pre><code class="ebnf language-ebnf">vowel = "a" | "i" | "u" | "e" | "o"
</code></pre><p>A newline can be put before every <code>|</code> symbol.<pre><code class="ebnf language-ebnf">vowel = "a" 
      | "i"
      | "u"
      | "e"
      | "o"
</code></pre><p><strong>Sequences</strong> represent productions following one after another in order. The sequence looks like two productions following one after another (unlike <strong>EBNF</strong> the comma isn't used in between sequenced productions). For example, rewriting the earlier <code>if</code> keyword example we could get:<pre><code class="ebnf language-ebnf">if-keyword = "i" "f"
</code></pre><p>The <strong>sequence</strong> operation has higher precedence than the <strong>alternative</strong> operation. The production for either string <code>"ab"</code> or <code>"cd"</code> can be defined as follows:<pre><code class="ebnf language-ebnf">random-string = "a" "b"
              | "c" "d"
</code></pre><p>Which will be the same as:<pre><code class="ebnf language-ebnf">random-string = ("a" "b") | ("c" "d")
</code></pre><p>And the same as:<pre><code class="ebnf language-ebnf">random-string = "ab" | "cd"
</code></pre><p>To make a sequence of alternatives instead put a pair of parens <code>()</code>. For example if I want to sequence string <code>"a"</code> with either <code>"0"</code> or <code>"1"</code> I could write:<pre><code class="ebnf language-ebnf">random-string = "a" ("0" | "1")
</code></pre><p>The rule <code>("0" | "1")</code> is called a <strong>group</strong>.<p>Besides the normal groups, this notation also has <strong>repetition</strong> groups that represent the production repeated zero or finitely many times. To repeat a production enclose it in braces (<code>{}</code>). For example one could define a grammar for decimal numbers as follows:<pre><code class="ebnf language-ebnf">decimal-digit = "0" | "1" | "2" | "3" | "4"
              | "5" | "6" | "7" | "8" | "9"

decimal-number = decimal-digit {decimal-digit}
</code></pre><p>The production for <code>decimal-number</code> represents a decimal digit followed by zero or more decimal digits.<p>And <strong>optional</strong> group that marks certain production as being optional. To mark production as optional enclose it with brackets (<code>[]</code>).<p>For strings it's possible to specify an <strong>escape sequence</strong> that will specify unicode codepoint. The syntax has a form of <code>\u+{x}</code>, where <code>x</code> is a hexadecimal character. For example, <code>"\u+30"</code>, <code>"\u+030"</code> and <code>"\u+0030"</code> all mean the same character - <code>"0"</code> (it has unicode codepoint <code>u+0030</code>).<p>Also the <strong>range</strong> operator can be used to specify an alternative of consecutive codepoints. The syntax looks like <code>"character1".."character2"</code>. It takes two single-character strings. The production matches at least one character with codepoints in between <code>"character1"</code> up until and including the codepoint of <code>"character2"</code>.<p>For example, the <code>decimal-digits</code> production from before could be written as:<pre><code class="ebnf language-ebnf">decimal-digit = "\u+30".."\u+39"
</code></pre><p>Or, alternatively:<pre><code class="ebnf language-ebnf">decimal-digit = "0".."9"
</code></pre><p>It is also possible to exclude a digit from a set of alternatives or from a range by using <code>except</code> word. For example to define a rule for all the decimal digits except <code>5</code> it's possible to write the following:<pre><code class="ebnf language-ebnf">digits-but-5: "0".."9" except "5"
</code></pre><p>The formal definition for the grammar using this grammar is therefore:<pre><code class="ebnf language-ebnf">decimal-digit   = "0".."9"
ascii-letter    = "a".."z" | "A".."Z"
identifier-char = ascii-letter | decimal-digits | "-" | "_"
identifier      = identifier-char { identifier-char }

ascii-symbol    = "\u+00".."\u+7f"
backslash       = "\u+5c"
double-quote    = "\u+22"
hex-digit       = "a".."f" | "A".."F" | "0".."9"
hex-number      = hex-digit | {hex-digit}
string          = double-quote (ascii-symbol | backslash "u+" hex-number) double-quote

production-rule = identifier "=" production
production      = alternatives "except" alternatives
alternatives    = sequence   {"|" sequence  }
sequence        = expression {    expression}
expression      = string
                | identifier
                | "(" production ")"
                | "{" production "}"
                | "[" production "]"
</code></pre><h3 id=12-the-source-encoding>1.2. The source encoding</h3><p>The <strong>x</strong> source file must be represented by a sequence of characters encoded using <strong>utf-8</strong> encoding. Other encodings should not be accepted. The utf-8 character codepoints range from <code>0</code> to <code>0x10ffff</code>.<p>The national symbols and other codepoints above ASCII range (<code>"\u+01".."0+7f"</code>) <strong>can only appear inside comments, strings or char literals</strong>.<p>The text is not canonicalized. So any codepoint representing decorated letter is different from two codepoints, one for the letter and one for the diacritics. So <code>だ</code> is treated differently from <code>た</code> followed by the dakuten (<code>u+3099</code>) codepoint. In particular, the string literals may generate different amounts of bytes for each representation of a character.<p>The two characters are different if the codepoints representing them are different. This also implies case-sensitivity.<p>The compiler disallows the NUL (<code>u+0000</code>) character anywhere in the source code except the endmost position, where it is ignored. UTF-8 Byte order mask (<code>0xFEFF</code>) is disallowed anywhere in the source except the very first position, where it is ignored.<p>In the formal syntax, <code>EOF</code> production is used to signify the end of input. The <code>any-char</code> production will be used to denote symbol with any codepoint.<pre><code class="ebnf language-ebnf">any-char = "\u+00".."\u+10ffff"
</code></pre><h3 id=13-lexemes>1.3. Lexemes</h3><p>The source code is represented by sequence of <strong>lexemes</strong>, a.k.a. <strong>tokens</strong>. Lexemes can be one of the following categories:<ul><li>Integer literal<li>String literal<li>Floating-point literal<li>Boolean literal<li>Pointer literal<li>Identifier<li>Special symbol (<code>"("</code>, <code>"$"</code>, <code>">="</code>, et cetera)<li>Comment</ul><p><strong>x</strong> is a <strong>free-form</strong> programming language. That means that the only role of whitespace and comments is to separate lexemes that otherwise might be tokenized in another manner. The meaning of the program stays the same if each whitespace character is replaced with other whitespace character or if any pair of whitespace characters is replaced by other whitespace character (excluding the whitespace <em>inside</em> the lexemes).<h4 id=131-whitespace>1.3.1. Whitespace</h4><p>Conceptually, whitespace characters are the characters that are "invisible" to the eye.<p>The following characters are considered to be <em>whitespace characters</em>.<ul><li><code>u+0009</code> (horizontal tab)<li><code>u+000a</code> (line feed)<li><code>u+000b</code> (vertical tab)<li><code>u+000c</code> (form feed)<li><code>u+000d</code> (carriage return)<li><code>u+0020</code> (space)</ul><p>Formally,<pre><code class="ebnf language-ebnf">whitespace = "\u+09".."\u+0d" | "\u+20"
</code></pre><p>A particular subset of whitespace is the set of <strong>line terminators</strong>. Line terminators are the characters that are treated by the compiler as being the end of the line. The characters that don't fall into that category are called <strong>line characters</strong>. The following characters are considered to be the line terminators:<ul><li><code>u+000a</code> (line feed)<li><code>u+000b</code> (vertical tab)<li><code>u+000c</code> (form feed)<li><code>u+000d</code> (carriage return)</ul><p>Formal syntax:<pre><code>line-terminator = "\u+0a".."\u+0d"
line-char       = any-char except line-terminator
</code></pre><h4 id=132-comments>1.3.2. Comments</h4><p>The <strong>comments</strong> are special kind of lexeme that are discarded by the compiler. <strong>x</strong> supports three kinds of comments:<ul><li>Line comments<li>Block comments<li>Nesting block comments</ul><p>The line comments start with <code>"#"</code> character that is not part of the string or char literal and ends with any of the line terminator characters, or by the end of file.<p>Formally:<pre><code class="ebnf language-ebnf">lc-first-char  = any-char  except "#" | "*" | line-terminator
line-comment   = "#" lc-first-char {line-char} (line-terminator | EOF)
</code></pre><p>The <strong>block comments</strong> are comments that have both start marker and the end marker. The block comments start with <code>##</code> and end with <code>##</code>. Block comments can not contain the string <code>##</code>. As a consequence, the block comments do not nest.<pre><code class="ebnf language-ebnf">bc-marker     = "##"
bc-char       = (line-char except "#") | ("#" (line-char except "#"))
block-comment = bc-marker {bc-char} bc-marker
</code></pre><p>In order to go around the limitation of no-nesting use <strong>nesting block comments</strong>. Instead of using single marker for the start and the end these comments use symmetric opening marker (<code>#*</code>) and ending marker (<code>*#</code>).<pre><code class="ebnf language-ebnf">nbc-start     = "#*"
nbc-end       = "*#"
nbc-char      = (line-char except "*") | ("*" (line-char except "#")) | nb-comment
nb-comment    = nbc-start {nbc-char} nbc-end
</code></pre><p>Also within line comments <code>##</code> and <code>#*</code> has no special meaning. Within block comments <code>#</code> and <code>#*</code> have no special meaning. And within the nested block comments, <code>#</code> and <code>##</code> have no special meaning.<p>The self-described examples of comments, either valid or invalid:<pre><code class="x language-x"># Line comment can contain ## and #*
# Комментарий на русском
#nospaces

outside

#*Anything starting with ## is a block comment*#

outside

## Inside comment ## outside comment ## inside comment ##

outside

### Block comment's text starts with '#' symbol. ##

outside

#*#*Error: the nesting block comment is not closed*# still inside
</code></pre><p>The line comments will also be used in the following examples of the <strong>x</strong> code to describe them.<h4 id=133-escape-sequences>1.3.3. Escape sequences</h4><p>In <a href=#136-character-literals><em>character literals</em></a> and in <a href=#137-string-literals><em>string literals</em></a>, apart from the raw unicode characters, the user can input a special sequence of characters that would map to a single character.<p>The list of escape sequences:<ul><li><code>\t</code> - horizontal tab symbol, maps to <code>\u+09</code><li><code>\n</code> - line feed symbol, maps to <code>\u+0a</code><li><code>\"</code> - the quotation mark, maps to <code>\u+22</code><li><code>\'</code> - the apostrophe symbol, maps to <code>\u+27</code><li><code>\\</code> - the backslash symbol, maps to <code>\u+5c</code><li><code>\u{x}</code> - the unicode codepoint (up to 6 characters)</ul><p>All other sequences starting with backslash are invalid. The compiler throws an error if it encounters such a sequence.<p>The <code>\'</code> and <code>\"</code> backslash sequences are available in either string literals or character literals. The compiler does not treat e.g. <code>\'</code> inside a string literal as an error.<p>Note that the unicode escape sequence maps to the code specified after <code>u</code>. Some examples:<pre><code class="x language-x">\u0       # maps to u+0000
\u00      # still maps to u+0000
\u000     # still maps to u+0000
\u0000    # still maps to u+0000
\u00000   # still maps to u+0000
\u000000  # still maps to u+0000
\u0000000 # counts as 2 characters: u+0000 followed by u+0030
\u110000  # invalid, the code point is greater than u+10ffff
</code></pre><h4 id=134-integer-literals>1.3.4. Integer literals</h4><p>The integer literals represent constant positive whole numeric values. The values can be specified in a variety of flavors: binary (bin) literals, octal (oct) literals, decimal (dec) literals and finally hexadecimal (hex) literals.<p>The literals in base other than 10 (and <em>optionally</em> in base 10) can be prefixed with a special prefix.<ul><li><code>0b</code> and <code>0B</code> are the prefixes for <em>binary</em> literals.<li><code>0o</code> and <code>0O</code> (zero followed by capital o) are the prefixes for <em>octal</em> literals.<li><code>0d</code> and <code>0D</code> are the prefixes for <em>decimal</em> literals.<li><code>0x</code> and <code>0X</code> are the prefixes for <em>hexadecimal</em> literals.</ul><p>The integer literal can optionally contain underscores for visual clarity, e.g. one million can be written as <code>1_000_000</code> or like <code>100_0000</code>. The integer literal can not start with an underscore. The underscore can, however appear anywhere after the first digit or after the prefix. So <code>0b_0</code> is valid. Since underscores are treated as digits, <code>0b_</code> is a valid integer literal as well.<p>The underscores are ignored. If the only digit after the prefix is the underscore, e.g. in the case <code>0b_</code>, then the value of the literal is <code>0</code>.<p>Whatever the base is, the final parsed value has to be no greater than <code>922_3372_0368_5477_5808</code> (<code>0x80000000_00000000</code> in hex). If the specified value is greater, the compiler produces an error.<p>Due to how the complement of two works, there's a special restriction on the literal with the value <code>922_3372_0368_5477_5808</code>. This literal can only appear as an operand to a unary <code>-</code> operation, where it is statically converted to the value of <code>-922_3372_0368_5477_5808</code>. Otherwise no signed 64-bit integer can have a value of <code>922_3372_0368_5477_5808</code> or bigger.<p>In hex literals, the case of characters is ignored. <code>0xf</code> and <code>0xF</code> mean the same thing.<p>The formal syntax for integer literals:<pre><code class="ebnf language-ebnf">bin-digit   = "0".."1" | "_"
bin-prefix  = "0b" | "0b"
bin-literal = bin-prefix {bin-digit}

oct-digit   = "0".."7" | "_"
oct-prefix  = "0o" | "0O"
oct-literal = oct-prefix {oct-digit}

dec-start   = "0".."9"
dec-digit   = "0".."9" | "_"
dec-prefix  = "0d" | "0D"
dec-literal = (dec-prefix | dec-start) {dec-digit}

hex-digit   = "0".."9" | "a".."f" | "A".."F" | "_"
hex-prefix  = "0x" | "0X"
hex-literal = hex-prefix {hex-digit}

int-literal = bin-literal | oct-literal | dec-literal | hex-literal
</code></pre><p>Here's an example of valid and invalid integer literals<pre><code class="x language-x">0          # valid, parsed as 0
00         # valid, parsed as 0
100_0000   # valid, parsed as 1000000
0d_1_000_0 # valid, parsed as 10000
0_         # valid, parsed as 0
0d_        # valid, parsed as 0
0d1F       # invalid, uses hexadecimal digits in decimal value
_1000      # invalid, actually parsed as identifier lexeme
0_d1000    # invalid, underscore is not allowed to break the prefix
</code></pre><h4 id=135-floating-point-number-literals>1.3.5. Floating-point number literals</h4><p>The fractional and decimal numbers are stored according to "IEEE754 standard for floating point arithmetic". The language uses the 64-bit values to represent the values.<p>The floating point literals are <strong>required</strong> to contain the <code>"."</code> (dot) symbol. In general, the floating point literal can be represented as<pre><code>[prefix] &LTwhole digits> . &LTfractional digits> [(E|P) [+|-] &LTexponent digits>]
</code></pre><p>It is <strong>required</strong> to have at least one whole digit, one fractional digit, and if the exponent part exists, one exponent digit. This requirement is not satisfied, as in <code>1.e+1</code>, the compiler throws an error. The required digit can be <code>_</code> if it's not the first digit of an unprefixed literal. Thus, <code>0_._e+_</code> is a valid floating point literal.<p>The compiler only supports two flavors of the floating-point numbers: decimal floating point numbers, and hex floating-point numbers. The hex floating-point literals are prefixed with <code>0x</code> or <code>0X</code>, the decimal floating-point literals are <em>optionally</em> prefixed with <code>0d</code> or <code>0D</code>.<p>In case of decimal floating point numbers, if the fractional digits are followed by <code>"e"</code> or <code>"E"</code> symbol, the exponent digits specify decimal exponent, where the value of the literal is in the form:<pre><code class="x language-x">value = (whole.fraction) * 10^exponent
</code></pre><p>Note the <code>10</code> in the base of the exponent.<p>In case of binary floating-point numbers, if the fractional digits are followed by <code>"p"</code> or <code>"P"</code>, the exponent digits specify binary exponent. And the value of the literal is in the form:<pre><code class="x language-x">value = (whole.fraction) * 2^exponent
</code></pre><p>Note the <code>2</code> in the base of the exponent.<p>If the value of a floating-point number is in the subnormal range, or exceeds the 64-bit floating-point maximum value, then compiler throws an error. If a floating point number is not exactly representable it is rounded to the nearest exactly-representable even number.<p>There are two special floating point literals: <code>nan</code> and <code>inf</code>. The first one represents errorneus value of NaN, according to IEEE754 standard, and the second one represents the value of positive infinity. Those two literals are case-sensitive.<p>The formal syntax is as follows:<pre><code class="ebnf language-ebnf">dec-prefix = "0d" | "0D"
dec-start  = "0".."9"
dec-digit  = "0".."9" | "_"
dec-whole  = (dec-prefix | dec-start) {dec-digit}
dec-fract  = {dec-digit}
dec-exp    = {dec-digit}
dec-float  = dec-whole "." dec-fract [("e" | "E") ["+" | "-"] dec-exp]

hex-prefix = "0x" | "0X"
hex-digit  = "0".."9" | "a".."f" | "A".."F" | "_"
hex-whole  = hex-prefix {hex-digit}
hex-fract  = {hex-digit}
hex-exp    = {hex-digit}
hex-float  = hex-whole "." hex-fract [("p" | "P") ["+"|"-"] hex-exp]

float-literal = dec-float | hex-float | "nan" | "inf"
</code></pre><p>Some examples:<pre><code class="x language-x">2.0E+1   # valid, parsed as 20.0
0d2.0E-1 # valid, parsed as (2.0 * 2^-1), or 1.0
2._      # valid, parsed as 2.0
0x_._e+_ # valid, parsed as 0.0
2E+1     # invalid, doesn't contain "." symbol
2.0p+1   # invalid, binary exponent in decimal value
0x2.0e-1 # invalid, decimal exponent in hex value
</code></pre><h4 id=136-character-literals>1.3.6. Character literals</h4><p>Character literals represent integer values of the unicode codepoints. They can be given either by giving character directly, or by providing an escape sequence.<pre><code class="ebnf language-ebnf">apostrophe  = "\u+2d"
backslash   = "\u+5c"
char-symbol = any-char except apostrophe | backslash

char-literal = apostrophe (char-symbol | escape-sequence) apostrophe
</code></pre><p>Some examples of character literals:<pre><code class="x language-x">'
'         # valid, contains newline character

'a'       # valid, maps to u+61
'я'       # valid, contains a Unicode character
'\''      # valid, maps to "'" (apostrophe) character
'"'       # valid, maps to '"' (quote mark) character
'\"'      # also valid, maps to '"' (quote mark) character
'\'       # invalid, the character literal isn't closed
''        # invalid, the character literal is empty
'\u11000' # invalid, the literal specifies character out of the range of Unicode codepoints
</code></pre><h4 id=137-string-literals>1.3.7. String literals</h4><p>String literals represent Unicode strings of text. The strings can contain any Unicode characters (including some control characters, like line feed)<pre><code class="ebnf language-ebnf">quote-mark  = "\u+22"
backslash   = "\u+5c"
str-symbol  = any-char except quote-mark | backslash

str-literal = quote-mark {str-symbol | escape-sequence} quote-mark
</code></pre><p>The examples of valid and invalid strings:<pre><code class="x language-x">"abcdef" # valid
"абвгед" # valid

"
hey
"        # valid, contains "\nhey\n"

"#"      # valid, contains the "#" character
</code></pre><h4 id=138-boolean-literals>1.3.8. Boolean literals</h4><p>There are two boolean literals: <code>true</code> and <code>false</code>.<pre><code class="ebnf language-ebnf">bool-literal = "true" | "false"
</code></pre><h4 id=139-pointer-literal>1.3.9. Pointer literal</h4><p>There is only one pointer literal: <code>null</code>.<pre><code class="ebnf language-ebnf">ptr-literal = "null"
</code></pre><h4 id=1310-identifiers>1.3.10. Identifiers</h4><p>Identifiers represent user-defined names and <em>keywords</em>. The identifiers may only contain ASCII letters, underscores and digits. However identifiers are not allowed to start with a digit.<p>The formal syntax:<pre><code class="ebnf language-ebnf">identifier-start = "_" | "a".."z" | "A".."Z"
identifier-char  = "_" | "a".."z" | "A".."Z" | "0".."9"
identifier       = identifier-start {identifier-char}
</code></pre><p>Some valid and invalid identifiers:<pre><code class="x language-x">cat    # valid
_cat__ # valid
d012   # valid
0d10   # invalid, starts with digit
a\ts   # invalid, can not contain backslash
жаба   # invalid, can not contain non-ascii characters
</code></pre><h4 id=1311-special-symbols>1.3.11 Special symbols</h4><p>A special set of character sequences is used for special symbols such as operators. For example <code>+=</code> is not plus lexeme followed by the equals lexeme, rather, it is a single lexeme. The compiler must match the longest operator from this sequence before advancing parsing to the next lexeme.<pre><code class="x language-x">+   +=   ~   ~=   $   <    &LT-   (    )
-   -=   |   |=   @   >    ->   [    ]
*   *=   &   &=   !   <=   ,    {    }
/   /=   <<  <<=  ?   >=   .    ;
%   %=   >>  >>=  ==  !=   :    ..
</code></pre><h3 id=14-keywords>1.4 Keywords</h3><p>Keywords are special types of identifiers whose usage is reserved for special occasions. User can not declare a variable or a type with the keyword name.<p>The list of keywords and their meaning is listed before<table><thead><tr><th>keyword<th>meaning<tbody><tr><td><code>bool</code><td>boolean type name<tr><td><code>char</code><td>32-bit integer type name<tr><td><code>int</code><td>64-bit integer type name<tr><td><code>byte</code><td>8-bit integer type name<tr><td><code>float</code><td>floating-point type name<tr><td><code>ptr</code><td>untyped pointer type name<tr><td><code>and</code><td>boolean and operation<tr><td><code>or</code><td>boolean or operation<tr><td><code>xor</code><td>boolean xor operation<tr><td><code>iff</code><td>boolean equivalence operation<tr><td><code>implies</code><td>boolean implication operation<tr><td><code>not</code><td>boolean negation operation<tr><td><code>sizeof</code><td>sizeof operation<tr><td><code>typeof</code><td>typeof operation<tr><td><code>offsetof</code><td>offsetof operation<tr><td><code>if</code><td><strong>if</strong> statement's starting lexeme<tr><td><code>else</code><td>else branch of the <strong>if</strong> statement<tr><td><code>while</code><td><strong>while</strong> statement's starting lexeme<tr><td><code>do</code><td><strong>do</strong> starting lexeme of the do-until statement<tr><td><code>until</code><td><strong>until</strong> part of the do-until statement<tr><td><code>try</code><td><strong>try</strong> starting lexeme of the try-catch block<tr><td><code>catch</code><td><strong>catch</strong> in the try-catch block<tr><td><code>let</code><td>variable declaration starting lexeme<tr><td><code>type</code><td>type declaration starting lexeme<tr><td><code>func</code><td>func declaration starting lexeme and func type name<tr><td><code>meth</code><td>method declaration inside structs<tr><td><code>this</code><td>encapsulated struct pointer<tr><td><code>operator</code><td>operator declaration inside structs<tr><td><code>struct</code><td><strong>struct</strong> declaration starting lexeme and struct type name<tr><td><code>enum</code><td><strong>enum</strong> declaration starting lexeme and enum type name<tr><td><code>union</code><td><strong>union</strong> declaration starting lexeme and union type name<tr><td><code>print</code><td>print statement's starting lexeme<tr><td><code>assert</code><td>assert statement's starting lexeme<tr><td><code>break</code><td>break statement<tr><td><code>continue</code><td>continue statement<tr><td><code>return</code><td>return statement<tr><td><code>throw</code><td>throw statement<tr><td><code>import</code><td>import file<tr><td><code>namespace</code><td>namespace scope</table><p>Note that <code>nan</code>, <code>inf</code>, <code>false</code>, <code>true</code> and <code>null</code> are not keywords. They are more like pre-declared identifiers.<p>Another name that one can not use when naming an identifier is <code>_</code> (single underscore). This identifier has special meaning. Note that <code>_</code> is not a keyword either.<h2 id=2-code-structure>2. Code structure</h2><p>This section covers the structure of the <strong>X</strong> code, starting down from the expressions syntax and ending with the most top-level syntax.<p>This section only covers the syntax of the parts of the code but does not give any explanation to their semantics and use-cases.<h3 id=21-expressions>2.1. Expressions</h3><h4 id=211-operators>2.1.1. Operators</h4><p>The unary operators of the language are:<table><thead><tr><th>Sign<th>Operator name<th>Description<tbody><tr><td><code>$</code><td>Addressof<td>Takes the address of a variable or other <em>lvalue</em><tr><td><code>@</code><td>Dereference<td>Gets the value of a variable or an address<tr><td><code>-</code><td>Negate<td>Negates the given value<tr><td><code>~</code><td>Bitwise negation<td>Negates integer value bit by bit<tr><td><code>not</code><td>Logical negation<td>Negates boolean value<tr><td><code>[N]</code><td>Subscript<td>Gets <code>N</code>'th element of a slice<tr><td><code>[N:M]</code><td>Subslice<td>Returns a slice by "cutting" through another slices starting at index <code>N</code> (inclusive) and ending with index <code>M</code> (exclusive)<tr><td><code>(...)</code><td>Function call<td>Call function with certain parameters</table><p>The binary operations of the language:<table><thead><tr><th>Sign<th>Operator name<th>Description<tbody><tr><td><code>+</code><td>Sum<td>Adds two values<tr><td><code>-</code><td>Difference<td>Subtracts a value from another<tr><td><code>*</code><td>Product<td>Multiplies two values<tr><td><code>/</code><td>Divide<td>Divides two values<tr><td><code>%</code><td>Modulo<td>Remainder of integer or float division*<tr><td><code>&</code><td>Bitwise and<td>Bitwise and between two integer values<tr><td><code>|</code><td>Bitwise or<td>Bitwise or between two integer values<tr><td><code>~</code><td>Bitwise not<td>Bitwise not between two integer values<tr><td><code><<</code><td>Shift up (right)<td><em>Logical</em> shift right<tr><td><code>>></code><td>Shift down (left)<td><em>Logical</em> shift left<tr><td><code>></code><td>Greater<td>Checks whether value is greater than another value<tr><td><code><</code><td>Less<td>Checks whether value is less than another value<tr><td><code>>=</code><td>No-less<td>Checks whether value is greater or equal than another value<tr><td><code><=</code><td>No-Greater<td>Checks whether value is less or equal than another value<tr><td><code>==</code><td>Equal<td>Checks whether value is equal to another value<tr><td><code>!=</code><td>Not equal<td>Checks whether value is not equal to another value<tr><td><code>:</code><td>Cast<td>Converts value of one type to a value of another type, preserving semantics<tr><td><code>::</code><td>Transmute<td>Converts the value of one type to a value of another type, preserving memory layout<tr><td><code>and</code><td>Logical and<td>The <strong>and</strong> operation of two boolean values<tr><td><code>or</code><td>Logical or<td>The <strong>or</strong> operation of two boolean values<tr><td><code>xor</code><td>Logical xor<td>The <strong>xor</strong> operation of two boolean values<tr><td><code>implies</code><td>Logical implication<td>"when <strong>x</strong> then <strong>y</strong>" relationship<tr><td><code>iff</code><td>Logical equivalence<td>Same as <code>==</code> operation on logical values</table><p>* The details of this operation are discussed in later sections.<p>Note, that operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&=</code>, <code>|=</code>, <code>~=</code>, <code>>>=</code>, <code><<=</code> and <code>=</code> are not part of the expression syntax. They make assignment <em>statements</em>, but can not be used in the expression context.<h4 id=212-operator-precedence>2.1.2. Operator precedence</h4><p>Operator precedence defined as follows. Every unary operator has higher precedence than any binary operator and any ternary operator. And for every unary operator, postfix unary operators have higher precedence than prefix unary operators.<p>According to these rules the following equalities hold for any suitable operands:<pre><code class="x language-x">@x$   ==   @(x$)   # dereferenced value of address of x
@f(x) ==   @(f(x)) # dereference return value of function f called with parameter x
~x$   ==   ~(x$)   # bitwise negation of address of x
-a[2] ==   -(a[2]) # negating second element of a slice
</code></pre><p>The unary operators are evaluated inside-out, starting from where the expression occurs. So <code>-~@x</code> is the same as <code>-(~(@x))</code>. Therefore the precision for all unary operators is clearly defined using just two rules.<p>The precedence table for the binary operators follows. Higher precedence level means higher precedence, i.e. the "binding" of those operators is stronger.<table><thead><tr><th>Precedence level<th>Operators<tbody><tr><td>7<td><code>|</code>, <code>~</code><tr><td>6<td><code>&</code>, <code><<</code>, <code>>></code>,<code>*</code>, <code>/</code>, <code>%</code><tr><td>5<td><code>+</code>, <code>-</code><tr><td>4<td><code>==</code>, <code>!=</code>, <code>></code>, <code><</code>, <code>>=</code>, <code><=</code><tr><td>3<td><code>and</code><tr><td>2<td><code>or</code>,<code>xor</code><tr><td>1<td><code>iff</code>, <code>implies</code><tr><td>0<td><code>:</code>, <code>::</code></table><h4 id=213-expressions-syntax>2.1.3. Expressions syntax</h4><p>In the previous sections operators in the language were informally introduced. Now the concrete syntax for expressions in <strong>x</strong> is presented.<pre><code class="ebnf language-ebnf">litexpr      = int-literal 
             | float-literal
             | char-literal
             | string-literal
             | identifier

call-params  = "(" [expression { "," expression }] ")"
subscript    = "[" (expression | ([expression] ":" [expression]) ) "]"

L7-op        = "|" | "~"
L6-op        = "&" | "<<" | ">>" | "*" | "/" | "%"
L5-op        = "+" | "-"
L4-op        = "==" | "!=" | ">" | "<" | ">=" | "<="
L3-op        = "and"
L2-op        = "or" | "xor"
L1-op        = "iff" | "implies"
L0-op        = ":" | "::"
UPref-op     = "-" | "~" | "@"
Upost-op     = "$" | call-params | subscript

expr-L7      = litexpr
             | "(" expression ")"

expr-postfix = expr-L7 { UPost-op }
expr-prefix  = { UPref-op } expr-postfix

expr-L7      = expr-prefix { L7-op expr-prefix }
expr-L6      = expr-L7 { L6-op expr-L7 }
expr-L5      = expr-L6 { L5-op expr-L6 }
expr-L4      = expr-L5 { L4-op expr-L5 }
expr-L3      = expr-L4 { L3-op expr-L4 }
expr-L2      = expr-L3 { L2-op expr-L3 }
expr-L1      = expr-L2 { L1-op expr-L2 }
expr-L0      = expr-L1 [ L0-op type ]

expression   = expr-L0
</code></pre><h3 id=22-types>2.2. Types</h3><h3 id=23-statements>2.3. Statements</h3><h3 id=24-code-structure>2.4. Code structure</h3><p>The source code structure of <strong>X</strong> represets a list of statements. Whenever the <strong>X</strong> program is compiled and then executed, conceptually the execution starts from the very first statement of the program. Unlike most other procedural and object-oriented programming languages, <strong>X</strong> does not require an execution entry point.<p>Therefore<pre><code class="x language-x">let x: int = 3;
while x < 10 {
  x += 1;
}

print x;
</code></pre><p>Is a valid <strong>X</strong> program.<h2 id=3-type-system>3. Type system.</h2><p>Type system is a special system inside a compiler that is meant for <em>prevention of logical errors</em> in the code. The typing discipline in <strong>X</strong> is <strong>static</strong>, meaning that all checks are done during the compilation, and not during the execution of the program, and <strong>strict</strong>, meaning that there is no implicit type conversions (except couple special cases).<p>Type is a special property of a value, that determines:<ul><li>The operations available on the value<li>The size of the value</ul><p>This section provides a set of definitions for the types used in this language, their relationships and groups of types used to determine which operations are available.<h3 id=31-types-and-type-categories>3.1. Types and type categories</h3><h4 id=311-primitive-types>3.1.1. Primitive types</h4><p>X language supports the following primitive types:<table><thead><tr><th>type<th>size<th>set of values<tbody><tr><td><code>bool</code><td>1<td><code>false</code>, <code>true</code><tr><td><code>byte</code><td>1<td><code>-2^7 .. 2^7-1</code><tr><td><code>char</code><td>4<td><code>-2^31 .. 2^31-1</code><tr><td><code>int</code><td>8<td><code>-2^63 .. 2^63-1</code><tr><td><code>float</code><td>8<td>Set of all IEEE754 64-bit representable floating-point numbers<tr><td><code>ptr</code><td>8<td><code>-2^63 .. 2^63-1</code></table><p>The syntax for primitive types is:<pre><code class="ebnf language-ebnf">prim-type = "bool"
          | "byte"
          | "char"
          | "int"
          | "float"
          | "ptr"

prim-or-alias = prim-type | identifier
</code></pre><p>The type aliases are just identifiers declared to mean some other type. They are <strong>not</strong> distinct types.<h4 id=312-typed-pointer>3.1.2. Typed pointer</h4><p>Typed pointers are the same size as the <strong>pointer</strong> types. However typed pointers preserve the information about the type of the value it points to.<p>The syntax for the typed pointer is:<pre><code class="ebnf language-ebnf">ptr-type = type "$" 
</code></pre><p>For example, the type "pointer to int" is written as follows:<pre><code class="x language-x">int$
</code></pre><p>The <em>typed pointer</em> will be referred to as <strong>a pointer</strong>, and the primitive pointers from the previous sections will be referred to as <strong>untyped pointers</strong>.<h4 id=313-slice-types>3.1.3. Slice types</h4><p>Slice types represent contiguous memory blocks. The values of slice-types can be thought of as pointer to the start of the block plus the size of the block.<p>Making slice of functions is illegal, since function's size is undefined (see <strong>p.3.1.4.</strong>). One can, however, make a slice of pointers of functions.<p>The syntax for the slice types is as follows:<pre><code class="ebnf language-ebnf">slice-type = type "[]"
</code></pre><p>Some examples of slices:<pre><code class="x language-x">byte[]    # legal, a slice of bytes
func()[]  # illegal
func()$[] # legal, a slice of pointers to funcs
</code></pre><h4 id=314-function-types>3.1.4. Function types</h4><p>Functions represent code that can be run with certain parameters and that can return a certain value. Thus function types encompass the types of the function parameters and the type of the return value of the function.<p>Values of function types have <strong>undefined size</strong>. The <code>sizeof</code> operator should return <code>-1</code> for every value of function type or the function type itslef. This also means you can not use function type to declare: - Struct fields - Variables - Function parameters<p>However the <strong>pointers to functions</strong> have similar semantics as functions and can be used instead.<p>The name of any of the parameters <strong>can not be a keyword</strong>. The parameters can not have a function type.<p>The syntax is as follows:<pre><code class="ebnf language-ebnf">sep          = "," | ";"

iden-list    = identifier {sep identifier}
func-param   = iden-list ":" type
func-params  = func-param {sep func-param}

func-mapping = "(" [func-params] ")" ["->" simple-type]
func-type    = "func" func-mapping
</code></pre><p>Some examples of function types:<pre><code class="x language-x"># function taking no parameters and returning nothing
func()

# function taking no parameters and returning an int
func()->int

# function taking two first int parameter and second float parameter
# and not returning a value
func(a: int, b: float)

# same as above, uses semicolon for separator
func(a: int; b: float)

# function taking one parameter of type
#   (pointer to function taking int, returning an int)
# and returning an int
func(a: (func(a: int)->int)$ )->int

# invalid, parameter can't be a function type
func(a: func())->int

# function taking 3 ints and 1 float, and 1 bool
# note the different separators
func(x,y;z:int, a:float; b: bool)
</code></pre><h4 id=315-struct-types>3.1.5. Struct types</h4><p><strong>Struct types</strong> represent groups of values stored together as a single unit of data. In pascal, also known as the <strong>record types</strong>.<p>In <strong>X</strong> struct types, can also contain <em>functions</em> and <em>methods</em>.<p><strong>Field declarations</strong> can not declare fields of function types (<strong>p.2.1.4</strong>), since the values of function type have <em>undefined</em> size. They can, however contain functions themselves.<p>If the struct type is declared via <code>type</code> declaration or <code>struct</code> declaration, none of the fields can directly contain field of the type being declared. Simply speaking, some recursive types are not allowed. However, the fields can take the type of e.g. "pointer to type" or "slice of type", since the size of pointer and slice is known.<p>Declarations in struct fields are be <strong>separated</strong> by either <code>","</code> (comma) or <code>";"</code> (semicolon). The function and method declarations inside structs may not be followed by the separator. All <em>field</em> declarations, except if it is the last in the struct to be terminated by either <code>","</code> or <code>";"</code>.<p>The order of the fields is the same as the order of the identifiers. <code>a,b,c: int, d: float</code> has the same order of fields as <code>a:int, b:int, c:int, d:float</code>. The compiler <strong>can not reorder fields</strong>.<p>The syntax for the struct fields is:<pre><code class="ebnf language-ebnf">sep          = ";" | ","

iden-list    = identifier {sep identifier}
struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier ":" func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier ":" func-mapping "{" stmt-list "}" [sep]

struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl

struct-type  = "struct" "{" struct-decls "}"
</code></pre><p>Here are some examples of structs:<pre><code class="x language-x"># C-like separation of fields
struct {
  a: int;
  b: float;
}

# Inline style
struct {a:int, b:float}

# Same as above, with trailing comma
struct {a:int, b:float,}

# Struct with packed decls, function and method
struct {
  x,y;z: int;
  c:float,

  func add: (a,b: int)->int {
    return a+b;
  }

  meth neg: () {
    x = -x;
    y = -y;
    z = -z;
  };
}

# valid, structs can contain pointer to functions as fields
struct {
  f: (func()->int)$;
}

# invalid, structs can not contain function fields
struct {
  f: func()->int;
}

# invalid, structs have to have at least one decl
struct {}
</code></pre><h4 id=316-union-types>3.1.6. Union types</h4><p><strong>TODO</strong><h4 id=317-enum-types>3.1.7. Enum types</h4><p><strong>TODO</strong><h4 id=318-the-syntax-for-types>3.1.8. The syntax for types</h4><p>In the previous sections all the types of the <strong>X</strong> have been shown, however the formal grammar had left-recursion because that way it was the easiest to understand.<p>The complete syntax for the types in <strong>X</strong> is presented below. All of the left-recursions have been removed.<pre><code class="ebnf language-ebnf">prim-type    = "bool"
             | "byte"
             | "char"
             | "int"
             | "float"
             | "ptr"
alias-type   = identifier

sep          = ";" | ","
iden-list    = identifier {sep identifier}

func-param   = iden-list ":" type
func-params  = func-param {sep func-param}
func-mapping = "(" [func-params] ")" ["->" simple-type]
func-type    = "func" func-mapping

struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier ":" func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier ":" func-mapping "{" stmt-list "}" [sep]
struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl
struct-type  = "struct" "{" struct-decls "}"

base-type    = prim-type | alias-type | struct-type | "(" type ")" 
simple-type  = base-type {"$" | "[]"}

type         = simple-type | func-type {"$" | "[]"}
</code></pre><h3 id=32-type-relationships-and-operations>3.2. Type relationships and operations</h3><h4 id=321-equivalence>3.2.1. Equivalence</h4><p>The equivalence defines relationship of types as being "the same" in the sense that is transparent to how they are defined. For example <code>int</code> and any type alias to <code>int</code> are equivalent, because they refer to the same type - <code>int</code>.<p>Types <strong>T</strong> and <strong>U</strong> are called <strong>equivalent</strong>, if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are <em>pointers</em> (typed) or <em>slices</em>, and their base types are <strong>equivalent</strong><li><strong>T</strong> and <strong>U</strong> are <em>functions</em> and all of the following is true: <ul><li><strong>T</strong> and <strong>U</strong> have <strong>equivalent</strong> return types<li><strong>T</strong> and <strong>U</strong> have the same number of parameters<li>For every parameter of <strong>T</strong>, and the corresponding parameter of <strong>U</strong>, they have <strong>equivalent</strong> types</ul><li><strong>T</strong> and <strong>U</strong> are <em>structs</em> and all of the following is true: <ul><li><strong>T</strong> and <strong>U</strong> have the same number of fields<li>For every field of <strong>T</strong>, and the corresponding field of <strong>U</strong>, they have <strong>equivalent</strong> types and same name.</ul><li><strong>T</strong> and <strong>U</strong> are primitive types and <strong>T</strong> = <strong>U</strong>.</ol><p>If none of the above is true, then <strong>T</strong> and <strong>U</strong> are <strong>not equivalent</strong>.<p>As a consequence of the definition the following applies:<ol><li>Any type <strong>T</strong> is equivalent to itself<li>If <strong>T</strong> and <strong>U</strong> are equivalent, then <strong>U</strong> and <strong>T</strong> are equivalent.<li>If <strong>T</strong> and <strong>U</strong> are equivalent, and <strong>U</strong> and <strong>V</strong> are equivalent, then <strong>T</strong> and <strong>V</strong> are equivalent.</ol><p>Note that structs are equivalent only if the fields are equivalent. Any two structs with the same fields but different functions inside them are also equivalent.<h4 id=322-assignability>3.2.2. Assignability</h4><p>The type <strong>T</strong> is <strong>assignable</strong> to <strong>U</strong> if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are <strong>equivalent</strong><li><strong>T</strong> is <em>pointer</em> and <strong>U</strong> is untyped <code>ptr</code><li><strong>U</strong> is <em>pointer</em> and <strong>T</strong> is untyped <code>ptr</code></ol><p>Otherwise <strong>T</strong> is <strong>not assignable</strong> to <strong>U</strong>.<p>As a consequence,<ol><li>Any type <strong>T</strong> is assignable to itself<li>If <strong>T</strong> is assignable to <strong>U</strong>, then <strong>U</strong> is assignable to <strong>T</strong>.<li>If <strong>T</strong> is assignable to <strong>U</strong>, and <strong>U</strong> is assignable to <strong>V</strong>, then <strong>T</strong> is assignable to <strong>V</strong>.</ol><h4 id=323-castability>3.2.3. Castability</h4><p>The castability determines whether values of one type can be cast, i.e. converted to another type. Castability does an explicit conversion, preserving the meaning.<p>Type <strong>T</strong> is <strong>castable</strong> to type <strong>U</strong> if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are same or different primitive types (<code>bool</code>, <code>byte</code>, <code>int</code>, <code>char</code>, <code>float</code>, <code>ptr</code>)<li><strong>T</strong> and <strong>U</strong> are <em>pointers</em> of any underlying types (including untyped <code>ptr</code>).<li><strong>T</strong> and <strong>U</strong> are <em>slices</em> of any underlying types.<li><strong>T</strong> and <strong>U</strong> are <em>structs</em> with all of the following holds: <ul><li><strong>T</strong> and <strong>U</strong> have the same number of fields<li>corresponding fields's types of <strong>T</strong> and <strong>U</strong> are <strong>assignable</strong></ul><li><strong>T</strong> and <strong>U</strong> are <em>functions</em> and all of the following holds: <ul><li><strong>T</strong> and <strong>U</strong> have the same number of parameters<li>corresponding parameters's types of <strong>T</strong> and <strong>U</strong> are <strong>assignable</strong></ul></ol><p>Otherwise <strong>T</strong> is <strong>not castable</strong> to <strong>U</strong>.<p>The details about the results of the <em>cast</em> operation are discussed later (<strong>p.????</strong>)<h4 id=324-transmutability>3.2.4. Transmutability</h4><p>The transmutability determines whether bit-sequence of one type can be re-interpreted as sequence of bits for another type.<p>Type <strong>T</strong> is <strong>transmutable</strong> to <strong>U</strong> if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are primitives that have the same size. (e.g. <code>int</code> and <code>float</code>)<li><strong>T</strong> is any pointer and <strong>U</strong> is any pointer.<li><strong>T</strong> and <strong>U</strong> are structs types of the same total size.</ol><p>Otherwise <strong>T</strong> is <strong>not transmutable</strong> to <strong>U</strong>.<h3 id=33-type-groups>3.3. Type groups</h3><p>In order to make discussions about operations and expressions easier the <strong>type groups</strong> are introduced in this section. Each operation is specified as acting on types of certain groups. For example the operations of addition, subtraction and multiplication are available for all types of "arithmetic" group. One type can belong to several groups.<h4 id=331-integer-arithmetic-ia>3.3.1. Integer arithmetic (IA)</h4><p>This is a group, such that for all values of this group the operations of the whole arithmetic, namely negation, addition, subtraction, multiplication, integer division, modulo division and all bitwise operations are defined.<p>The details of those operations and the acceptable and derived types are not discussed here. However we are going to list the types of the group <strong>IA</strong>:<ul><li><code>byte</code><li><code>char</code><li><code>int</code><li><code>ptr</code><li>All typed pointers</ul><h4 id=332-floating-point-arithmetic-fa>3.3.2. Floating-point arithmetic (FA)</h4><p>For the values of <strong>FA</strong> group types, the operations of negation, addition, subtraction, multiplication, division and modulo division are defined.<p>The only type of the group <strong>FA</strong> is <code>float</code>. Unlike <strong>IA</strong> group, values of <strong>FA</strong> group types can not access bitwise operations.<h4 id=333-logical-log>3.3.3. Logical (Log)</h4><p>For the values of <strong>Log</strong> group, boolean operations are defined: logical negation, logical and, or, xor, implication and equivalence. The only type of this group is <code>bool</code>.<h4 id=334-ordered-ord>3.3.4. Ordered (Ord)</h4><p>For the values of <strong>Ord</strong> group types the following operations of relation are defined: less-than, greater-than, not-less (greater-or-equal), not-greater (less-or-equal).<p>The following types have the <strong>Ord</strong> category:<ul><li><code>bool</code><li><code>byte</code><li><code>char</code><li><code>int</code><li><code>float</code><li><code>ptr</code><li>All typed pointers</ul><h4 id=335-subscriptable-sub>3.3.5. Subscriptable (Sub)</h4><p>For the values of <strong>Sub</strong> group, the operation of subscripting is available. The types of this group are all the typed pointers and all the slices.<h4 id=336-callable-call>3.3.6. Callable (Call)</h4><p>For the values of <strong>Call</strong> group, the operation of function calling is available. The types of this group are functions, method functions and pointers to functions.<h4 id=337-structure-str>3.3.7. Structure (Str)</h4><p>For the members of <strong>Str</strong> group, the operation of member access is accessible. The types of this group are all the <code>struct</code> types, pointers to structs and any slice types.<p>The details of which particular fields are accessible is described, whenever the member access operation is described.<h2 id=4-declarations>4. Declarations</h2><p>Declarations introduce name to the vocabulary of a program.<p>In <strong>X</strong> there are several types of declarations.<ul><li>Variable declarations<li>Type declarations<li>Function declarations<li>Struct declarations<li>Method declarations</ul><p>The name introduced by any declaration can not be any of the keywords (<strong>p.1.4</strong>). The <em>shadowing</em> of declarations is <strong>not allowed</strong>.<p>This section describes declarations' syntax, scoping system, visibility in detail.<h3 id=41-scope-system>4.1. Scope system</h3><p>Every element of the language that can contain declarations has it's own <strong>scope</strong> (e.g. function scope). I will refer to the statements or expressions inside those containers as also being <em>inside their scope</em>.<p>Every scope, except the <strong>global</strong> scope has a <strong>parent scope</strong>. If scope <strong>s</strong> belongs to statement <strong>S</strong>, the parent of the scope <strong>s</strong> is the scope, where <strong>S</strong> is located.<pre><code class="x language-x"># global scope
func a: (x:int) { # function scope
  # block scope
}
</code></pre><p>In the example above you can see three scopes: the global scope, the function scope and the block scope. The block scope is part of the block statement. The block statement is part of the function, so the function scope is the parent of the block scope. Also the function scope is part of the function statement, which is the part of the global block. Therefore the global scope is the parent of the function scope.<p>Every scope has a list of <strong>own</strong> declarations and a list of <strong>inherited</strong> declarations associated with it. The list of own declarations consists of all the declarations within the element with which the scope is associated (except the elements within the elements of the associated element).<p>The list of inherited declaraions specifies the declarations that the scope "sees" in it's parent scope. Of course not all of the declarations are visible. In the following example inside the block scope only the variable <code>x</code> is visible but not <code>y</code>:<pre><code class="x language-x">let x: int = 4;
if x&LT10 {
  let z: int = x+y;   #error, y is not visible in this scope
}
let y: int = 4;
</code></pre><p>That's why it's important to specify that scope only inherits those declarations from parent located <em>before</em> it. What the word before means depends on the context, but in general it literally means "occuring earlier in the source". One exception is the variable declaration expression's scope:<pre><code class="x language-x">let x: int = x~x;    # error, x is not visible in the initializer of x
</code></pre><p>However the function declarations are inherited without that requirement. Therefore the following code is valid:<pre><code class="x language-x">{
  add(2,3);  # valid, even though it is located "after" this block scope
}

And the struct declarations allow their name to be 

func add: (x,y: int)->int {
  return x+y;
}
</code></pre><p>Based on the kind of the element, where the declarations are located, the scope have distinct kinds:<ul><li>Block scope (Every statement block has it's own scope)<li>While scope (applied to <code>while</code> statements)<li>If scope (applied to <code>if</code> statements)<li>Function scope (applied to methods and functions)<li>Struct scope (applied to <code>struct</code> declarations)</ul><h4 id=411-basic-relationships>4.1.1. Basic relationships</h4><p>The scope <strong>P</strong> is an <strong>ancestor</strong> of <strong>S</strong> if one of the following applies:<ul><li><strong>P</strong> is a parent of <strong>S</strong><li><strong>P</strong> is a parent of an <strong>ancestor</strong> of <strong>S</strong></ul><p>If scope <strong>S</strong> has parent <strong>P</strong>, then <strong>P</strong> has <strong>child</strong> <strong>S</strong>.<p>The scope <strong>S</strong> is <strong>descendant</strong> of <strong>P</strong> if one of the following applies:<ul><li><strong>S</strong> is a child of <strong>P</strong><li><strong>S</strong> is a child of <strong>descendant</strong> of <strong>P</strong></ul><p>You can think of an <em>ancestor</em> as being a enclosing scope enclosing <strong>S</strong> and <em>descendant</em> scope as being "inside" of <strong>P</strong>.<p>In order define accessibility and visibility we will define an addition notion of declaration being located "before" another declaration or the scope. The phrase <strong>before X</strong> means either before <strong>X</strong> in the current scope, or before any of the ancestor scopes of <strong>X</strong>.<h4 id=412-visibility>4.1.2. Visibility</h4><p>Scope <strong>S</strong> is said to <strong>inherit</strong> declaration <strong>D</strong> from the parent scope <strong>P</strong> if the following conditions are met:<ul><li><strong>D</strong> is in <strong>P</strong><li><strong>D</strong> is located <strong>before</strong> <strong>S</strong><li>When <strong>S</strong> is a struct or function scope, <strong>D</strong> is a type declaration</ul><p>In scope <strong>S</strong> declaration <strong>D</strong> is called <strong>visible</strong> if one of the following is true:<ul><li><strong>D</strong> is in <strong>S</strong><li><strong>S</strong> inherits <strong>D</strong> from its parent <strong>P</strong>, and <strong>D</strong> is <strong>visible</strong> in <strong>P</strong></ul><p>A declaration <strong>D</strong> is called <strong>accessible</strong> from statement or scope <strong>s</strong> if the following conditions are met:<ul><li><strong>D</strong> is visible from the scope of <strong>S</strong><li><strong>D</strong> is located before <strong>s</strong><li><strong>S</strong> inherits <strong>D</strong> from <strong>P</strong></ul><h4 id=411-shadowing>4.1.1. Shadowing</h4><p><strong>Shadowing</strong> is considered to occur whenever to or more distinct declarations are <strong>accessible</strong> from some scope.<p>If any declaration <strong>D</strong> shadows any declaration <strong>d</strong>, the compiler throws an error.