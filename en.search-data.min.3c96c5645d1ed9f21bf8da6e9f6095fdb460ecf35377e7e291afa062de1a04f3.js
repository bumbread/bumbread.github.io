'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/sects/boot-sector/bios/',title:"BIOS",section:"Sects",content:"BIOS \u0026ndash; Basic Input-Output System #  BIOS is a program that is stored on the Motherboard ROM. When CPU starts up the first thing that runs is BIOS code. BIOS performs the following:\n Initializes hardware (display, keyboard, disk) drivers that are necessary for the OS to boot. Sets up its API for use by the OS in the form of Interrupts. Reads setup information stored in CMOS (a special memory chip on motherboard) and find the first Bootable disk. Load the first 512 bytes of the bootable disk into the memory at address 7C00 and transfer execution control to the bootloader code.  BIOS basically provides OS with the ability to boot itself independently of the hardware present.\nBIOS provides its services to the OS as CPU Interrupts. In order to request a BIOS service, one has to call interrupt instruction on the CPU and provide parameters in the registers.\nInterrupt vector 10 is a display functions service, interrupt vector 13 is used as disk services. Here\u0026rsquo;s the example of using display functions to draw a character to the screen:\nmov ah, 0x0E ;; 0x0E means \u0026#34;Print character\u0026#34; function mov al, \u0026#39;H\u0026#39; ;; Character to print mov dx, 0x000F ;; Page number and Color int 10h Upon executing this program, a white character \u0026lsquo;H\u0026rsquo; should appear on the screen.\nIncompatibilities between BIOSes #  Since the IBM PC era, computers were evolving, and new hardware appeared. IBM PC Compatibles needed to add the support for that hardware, and since there wasn\u0026rsquo;t any standard to which interrupt numbers correspond to which services and how the hardware should be handled, different PC manufacturers handled hardware differently.\nOther source of incompatibility is the direct effect of reverse engeneering of the original IBM PC by the manufacturers. Since the original BIOS wasn\u0026rsquo;t copied, but reverse-engeneered, some parts remained incompatible.\nAs such the software that runs under BIOS (in particular that refers to the bootloader) should be careful not to make too much assumptions about the environment it runs in.\nNow I will descript some pitfalls that can occur when writing a portable bootloader. Part of bootloader in the MBR should set up the environment so that the rest of the bootloader can make assumptions about it.\n1. The value of code segment and instruction pointer on bootloader entry #  As I told earlier, the bootloader is loaded by BIOS at address 7C00. However, there are many values segment:offset pairs that resolve to the same address. A trivial pair would be 0000:7C00, but 07C0:0000 is also possible.\nMost BIOSes set it to 0000:7C00, but some BIOSes set it to 07C0:0000. In any case it is a good idea to reset the address e.g. to 0000:7C00 by performing a Long jump to it.\njmp 0000:.next .next: Long jump sets the code segment value to the one specified in the operand.\n2. Stack location #  Where BIOS puts stack is undefined. Depending on the particular way your bootloader works, assuming a good stack location may end up badly. For example BIOS may set up the stack at the point, where you load the second stage bootloader to.\nWe could set the stack at 07C00. Note that when the next value is pushed to the stack, the stack pointer is subtracted from first, then the data is pushed. So the first word would be pushed right below the boot sector.\nAlternatively we could set the stack to 9000:0000. In such case, when the value of SP is decremented, the register overflows, and the data is pushed at the end of the segment.\nHere\u0026rsquo;s the example of setting up the stack at the latter location:\nmov bx, 9000h mov ss, bx mov sp, 0000h 3. Segment registers DS, ES #  The default data segment register, and extra segment register are also pretty much undefined. Its a good idea to zero-out the segments.\nmov bx, 0000h ; `xor bx, bx` does the same, but takes less space mov ds, bx mov es, bx 4. Directionality flag DF #  If you\u0026rsquo;re a big fan of x86 string instructions, i.e. stosb, lodsb, movsb, then you should know that they change the value of SI and DI registers (either post-decrement or post-increment) depending on the value of DF flag.\nProgram should clear the direction flag if it uses these instructions and assumes right directionality.\ncld "}),a.add({id:1,href:'/sects/boot-sector/disks/',title:"Disk organization",section:"Sects",content:"Disk organization #  We had already discussed that the during IBM PC time the main two non-volatile memory storage devices were Hard drives and Floppy disks, which turn out to have similar structure.\nSo it would be useful to discuss the physical structure of the hard drives first.\nPhysical structure #  The disk consists of basic addressable units \u0026ndash; sectors. One can not read or write less than a sector direcrly off of a disk.\nGroup of sectors located at the same radius from the origin are organized into tracks. The tracks have circular shape. Group of tracks that spans along multiple heads is called cylinder.\nCHS Addressing #  Early hard drives did not have an embedded controller, that could do address transformations. You could not say \u0026ldquo;give me 128th sector\u0026rdquo;. Instead, you had to specify the location of a sector with accordance to its physical structure \u0026ndash; giving the number of the sector, intex of the head and the cylinder.\nThis is what CHS (Cylinder-Head-Sector) addressing is. Address of a sector is specified with a tuple of three numbers (C/H/S). The numbering of sectors starts from one, so the sector number can not be zero. Cylinder and Head are zero-based.\nBIOSes use 8 bytes for head, 10 bytes for cylinder and 6 bytes for the sector. The whole data fits in 3 bytes:\nCCCCCCCC CCSSSSSS HHHHHHHH\rWhere C specifies a cylinder bit, S specifies a sector bit, and H specifies a head bit.\nAnd since the addressing information was limited by these three bytes, there were limits for each of the measurements:\n Sector: 1..63 Cylinder: 0..1023 Head: 0..255  Although the actual limit was 255, there was a bug in IBM PC BIOS, that would crash if it saw a drive with 255 heads. Therefore the actual limit for the heads index was 254.\nSo CHS addressing supported a drive with at most 63 sectors per track, 1024 tracks per head and 255 heads. Given the sector is 512 bytes, the limit for the CHS addressing is:\n512*63*1024*255 = 8422686720 bytes = 8032.5 Mb\rAbout 8 Gb. That is way too little to support modern hard drives and USB flashes. And since some devices had a different geometry, e.g. different number of tracks per second, the actual limit is even less.\nIBM PC only supported floppy disk storage. So it makes sense why the 8 Gb limit was fine. (Hard disk storage was introduced with IBM PC/XT)\nSometimes to get around that some devices had embedded a controller that would lie to BIOS about device\u0026rsquo;s geometry. And when BIOS was talking to the device, the controller would implicitly convert the \u0026ldquo;virtual\u0026rdquo; CHS address that BIOS gave it into the \u0026ldquo;real\u0026rdquo; one that was matching the device\u0026rsquo;s geometry.\nSo for modern hard disks CHS address no longer correspond to the physical layout of the drive.\nLBA addressing #  To further overcome the 8 Gb limit of CHS addressing IBM introduced BIOS Enhanced Disk Drive Services, that introduced a new 64-bit addressation of the sectors on the disk.\nThe LBA address was a single 64-bit number corresponding to the zero-based index of the sector. This is pretty straightforward. With this the limit was raised until 8589934592 Tb. That\u0026rsquo;s pretty much infinite.\nHowever by ATA-6 specification only 48 bits are used. So the actual limit is 131072 Tb.\n"}),a.add({id:2,href:'/sects/boot-sector/hw-communication/',title:"Hardware communication",section:"Sects",content:"Hardware communication #  Inside a computer there are various hardware components: RAM, CPU, Monitor, Hard drive, plug-in devices and so on. These devices have to be able to talk to each other in some way.\nThe way in which that is done is via connecting the hardware components to the same sets of wires. One set of wires is for specifying the value to transfer between devices, the other set of wires is for specifying the address to transfer the data to. The third set of wires synchronises the devices so that reads do not occur during writes, and specifies the type of operation to be performed.\nBuses #  Those sets of wires is something that\u0026rsquo;s called a Bus. Computers usually have three buses: the address bus, the data bus and the control bus.\nAddress bus stores the numerical value of an address, the data bus stores the data to be transferred and the control bus specifies other data such as the type of operation (read or write), the clock synchronization and other.\nHere\u0026rsquo;s the basic picture:\nEssentially buses are a group of wires that correspond to some numerical value. 16-bit bus width means that the maximum numeric value that the bus can transfer is 65535.\nThe control bus could specify these kinds of operations:\n Memory Read Memory Write IO Read IO Write CPU Interrupt (hardware wants CPU reaction immediately)  As such there are three ways of communicating with hardware.\n1. Memory-mapped IO #  Each device gets its own memory addresses in the address space. When processor uses address bus to write data to those addresses, the device sees that and reacts correspondingly.\nSo the address space used for this operation is the same for RAM and other devices.\nFor example Video Graphics Array (VGA) memory behaves that way. It is mapped at the address of 0xB8000 in RAM and writing to that memory will cause the pixels on the screen to change.\nWhen using memory-mapped IO, the processor instruction used to communicate to hardware are the same as the ones used to write to memory (in x86 it\u0026rsquo;s mov instruction)\n2. Port-mapped IO. #  In this case the address spaces for RAM reads/writes is different than for Hardware communications. This is either done by specifying IO operation on the control bus, or by using an entirely separate IO Bus.\nEach device gets its own set of Ports, and CPU can read and write to each port. This is done using different instructions than accessing memory.\nOn x86 in and out instructions are used for communications with port-mapped devices.\n3. Interrupts #  When memory-mapped IO and port-mapped IO are a way for CPU to talk to device, hardware interrupts are a way for devices to talk to CPU.\nThis is used for e.g. keyboards. If the communication with keyboards was done via one of the ways described above, the CPU would have to wait until the state of the keyboard changes. This consumes cycles that could be spend doing other useful work.\nSo instead of that keyboard can notify processor that a key was pressed. When interrupt is issued, the processor temporarily stops executing the code it was executing and starts handling the interrupt handler. After interrupt handler finished executing the CPU restores its state and continues executing the thing it was executing.\n"}),a.add({id:3,href:'/sects/boot-sector/mbr/',title:"MBR",section:"Sects",content:"MBR \u0026ndash; Master boot record #  MBR refers to the very first 512 bytes of the disk. MBR is loaded by BIOS into the memory at address 7C00. The MBR holds the code and some metadata about the drive that the OS can use in the boot process, as well as OS\u0026rsquo;s bootloader itself.\nHere\u0026rsquo;s the basic structure of the MBR:\n   Address Size Description     0000-01BD 446 byte Bootloader   01BE-01CD 16 byte 1-st partition entry   01CE-01DD 16 byte 2-nd partition entry   01DE-01ED 16 byte 3-rd partition entry   01EE-01FD 16 byte 4-th partition entry   01FE-01FF 2 byte Magic number 55h AAh    The magic number is used by the BIOS to determine whether the disk is bootable. If the the two last bytes of the MBR do not match the signature, BIOS will refuse to boot from that disk.\nPartitioning #  The partitions are a way of subdividing a drive, such that each partition can contain a different filesystem or a even a different OS. This process is typically only applicable to large disks. Floppy disks are considered to be unpartitioned media.\nOn partitioned media, MBR code must find the first bootable partition and transfer control to the first sector of that partition \u0026ndash; Volume Boot Record (VBR). The structure of the VBR resembles the structure of MBR, except VBR doesn\u0026rsquo;t have the partition entries:\n   Address Size Description     0000-01FD 510 byte Bootloader   01FE-01FF 2 byte Magic number 55h AAh    On unpartitioned media, the MBR performs the role of VBR and also doesn\u0026rsquo;t contain the partition entries.\nPartition entries #  On partitioned media MBRs the partition entries specify the location and the span of the partition, it\u0026rsquo;s type and a special flag specifying whether an OS can boot from that partition, i.e. bootable flag.\nDuring OS boot process MBR can check every partition until it finds the one both with the right type and bootable flag set. Then it should load the first sector of that partition (the VBR) into memory and transfer control to it.\nThe VBR would be responsible for loading the OS from the filesystem. If VBR is too small to read the filesystem, a third-stage bootloader may be used.\nNon-bootable partitions typically just contain the files on filesystem and used on e.g. flash drives.\nHere\u0026rsquo;s the basic layout of a 16-byte partition entry field on an MBR:\n   Offsets Size Description     00-00 1 byte Bootable flag (00h - inactive, 80h - bootable)   01-03 3 byte CHS address of the first sector   04-04 1 byte Partition type   05-07 3 byte CHS of the last sector   08-0B 4 byte LBA of the first sector   0C-0F 4 byte Number of sectors    Note that both CHS and LBA are used in the partition entries. It\u0026rsquo;s better to use BIOSes extended drive read functions and LBA addressing, because of the 8 Gb limitation of CHS. 32-bit LBA values can address up to 2 Tb of the disk.\n"}),a.add({id:4,href:'/sects/boot-sector/memory/',title:"Memory organization",section:"Sects",content:"Memory organization in x86 real mode #  As was discussed earler all later x86 processors start in real mode, which limits data operands to 16 bits and the address bus to 20 bits. The processor can use segmentation to access the memory beyond 64 Kb.\nAfter BIOS loads MBR into RAM, the memory is in a certain state.\n   Address range Size Description     00000-9FFFF 640 kb RAM   A0000-BFFFF 128 kb Video display memory   C0000-FFFFF 256 kb Motherboard ROM    The first 640 Kb make the Conventional RAM \u0026ndash; the part of memory that can be freely used by the programs to store their data etc. In 16-bit era this space was used by the actual user programs and the OS, now is pretty much only used by the bootloader and the OS Kernel.\nThe 128 Kb after that are used by various video display drivers \u0026ndash; CGA, EGA and VGA. In particular VGA can still be used today to draw text graphics to the screen.\nThe last 256 Kb, is what the motherboard ROM is mapped \u0026ndash; it contains BIOS, the program that is responsible for hardware communications on early stages of OS Loading process.\nConventional Memory map #  After BIOS loads MBR into the RAM, this is the map of various parts in the conventional memory:\n   Address range Size Description     00000-003FF 1kb Interrupt vector table (x86)   00400-004FF 256 byte Reserved (x86)   00500-07BFF 29 kb 768 byte Unused   07C00-07DFF 512 byte MBR   07E00-9FBFF 638 kb Unused   9FC00-9FFFF 1 kb Extended BIOS area    Interrupt vector table is used by x86 processor to map Interrupt handlers to different interrupt numbers. BIOS uses this table to map interrupts 10h and 13h to BIOS procedures, thus providing an API to the bootloader to provide screen printing and other services.\nThe last 1 kb stores additional BIOS data that is used during communication with hardware.\nThe 512 bytes starting at 7C00 is where the MBR is loaded to by BIOS. The dada starting from 00500 to 9FBFF can be freely used by the application (although some BIOSes have bigger extended area (2kb or 4kb), so touching the end of the unused are may be a bad idea)\n"}),a.add({id:5,href:'/sects/boot-sector/pc-history/',title:"Overview of PC history",section:"Sects",content:"Overview of PC history #  Before we dive into inspecting various components that participate in boot-time function of the OS, I would like to make a special overview of the history of PCs. This will make the understanding of BIOS as well as other \u0026ldquo;features\u0026rdquo; of the booting process much easier.\nThe term PC was due to one mainstream computer from IBM called the IBM PC. BIOS in IBM PCs was the hardware abstraction layer that allowed OSes to perform hardware input/output functions independently of the actual hardware used in the system.\nAlthough technically the term \u0026ldquo;PC\u0026rdquo; most of the time refers to an x86 computer capable of running Windows, Linux. PC can be contrasted to another term \u0026ndash; \u0026ldquo;Mac\u0026rdquo;.\n1. IBM PC #  IBM PC was using the Intel 8088 processor, which is a variant of Intel 8086 processor (note that the latter processor\u0026rsquo;s name ends in \u0026ldquo;86\u0026rdquo;).\nJust as 8088, the 8086 was a 16-bit processor, meaning registers could store numbers up to 65535 and address up to 64 Kb of memory. The address bus was 20 bits however. Using the segment:offset addressing, the processor was able to address up to 1 Mb of memory.\n640 Kb of that memory was given to OS and user programs, the other 384 Kb were dedicated to video memory, and the motherboard ROM.\nThe main storage media at the time were the floppy drives and hard drives. Their physical structure was similar. Each one of them was split into 512-byte sectors. It is only possible to read or write the whole sector at once (no single-byte writes). The difference between floppies and hard drives is that floppies were used as portable media just like USB flash is used now.\nMS-DOS was basically the only Operating system used with this PC.\n2. IBM PC Compatibles #  Since IBM PC was mainstream and never standartized at the same time, it was desirable for many companies to produce and sell similar and compatible in functionality systems. These systems are called IBM PC Compatibles.\nThe processor was pretty much the same \u0026ndash; 8088/8086. Because the functions of BIOS were never documented, the BIOSes on the motherboards had to be reverse-engeneered.\nEven though many of those systems were able to be basically compatible with IBM PC, in particular being able to load MS-DOS, they weren\u0026rsquo;t fully compatible. It could be that some PC Compatibles were implementing extra functionality, or underimplementing some functionality. Some functionality could be implemented with bugs et cetera. Point is \u0026ndash; they weren\u0026rsquo;t fully compatible.\n3. Now #  The incompatibilities between PC Compatibles have become worse as new hardware appeared. For example, as new hardware appeared and old hardware evolved, different BIOSes were handling the changes differently.\nFor example when USB flash became used, some BIOSes chose to handle them as floppies, and other chose to handle them as drives.\nThe Intel CPUs have evolved. 8086 had evolved into 80186, then into 80286 and then into 80386. The names of the processors all ended in \u0026ldquo;86\u0026rdquo;, so it was common to call them collectively as \u0026ldquo;x86\u0026rdquo; (this is the convention used in this book too).\nIt was desirable for Intel to keep the backwards compatibility within their processors, so that newer processor could be able to work with older software. That\u0026rsquo;s why even new 64-bit Intel processors start up in so-called real mode, a special 16-bit mode that uses 20-bit address bus.\nEven to this day many systems remain IBM PC Compatible, that\u0026rsquo;s why knowing the history can greatly improve the understanding of why some things are the way they are.\n"}),a.add({id:6,href:'/sects/boot-sector/power-button/',title:"When the power button is hit..",section:"Sects",content:"When the power button is hit.. #  .. A set of actions is performed by different components of your PC. The power button is connected to a motherboard (also called main board or system board) - the heart of your computer.\nPower on #  After you hit the button, the first thing motherboard tries is to provide various components with electrical power. However there may be various instabilities in the electrical current. You would not like to burn up your CPU by providing too strong voltage to it.\nThat\u0026rsquo;s why the motherboard sends the signal to a power supply. The power supply\u0026rsquo;s job is to ensure that the voltages are within the acceptable range (as per specification of the motherboard). After the voltages and currents have stabilized the power supply device sends Power Good signal back to the motherboard.\nThen the motherboard knows that it can power other hardware components without blowing them up. So it powers them up.\nCPU Initialization #  CPU is powered up. In case of x86 CPUs, after the power-up motherboard sends a signal to the reset# pin. What this does, is it restores the state of CPU into a known initial state. Namely it sets the values of registers to a certain state.\nGeneral purpose registers values are left undefined. EFLAGS register is initialized so that the lower 16 bits make up the value 0002h. The other bits are undefined. Segment registers are zeroed-out.\nWhat we\u0026rsquo;re interested in is EIP register, responsible for keeping the address of the next instruction to be executed. We\u0026rsquo;re also interested in the values of Code segment (which is zeroed out, as specified above), and Code segment base (which is a special hidden part of Code Segment).\nWithout going into much detail the tuple (EIP, CS, CS.base) together make up the address 0xFFFFFFF0. That location is called a reset vector, a.k.a. the address of the first instruction to be executed.\nBIOS #  The reset vector is not an address in RAM \u0026ndash; at this stage the contents of RAM are basically undefined. But since all components are connected to the same Address Bus, the other hardware components can also be mapped to a certain address.\nThe address 0xFFFFFFF0 points to the motherboard ROM (Read Only Memory). The motherboard contains a program called BIOS (stands for Basic Input Output System).\nBIOS performs the following functions:\n Initialize the hardware (Set up interrupt handles etc) Load the Operating System Bootloader Provide the API for bootloader to load OS into memory  In a sense it is the lowest-level hardware-abstraction component.\nOS is stored on a disk. It can either be a floppy, hard drive, CD-disk or a USB flash. In either case the first 512 bytes of the disk contain the OS boot loader.\nBIOS\u0026rsquo;s job is to load those 512 bytes into RAM and start execution of the boot loader code. Boot loader uses BIOS functions to read other sectors from the disk and find the OS on the disk.\nBoot loader #  The operating system loading (booting) process is usually chained because of various size or hardware limitations. Typically a \u0026ldquo;less-powerful\u0026rdquo; loader loads a \u0026ldquo;more-powerful\u0026rdquo; loader into memory, which in turn loads \u0026ldquo;even more powerful\u0026rdquo; loader or loads the OS itself.\nThe program that loads OS into memory is called Boot Loader. The part of the bootloader that is stored in the first 512 bytes of a hard drive is called Master Boot Record (MBR), and it is the code that gets loaded by the BIOS into the RAM.\nAfter the boot loader has loaded the OS into RAM, it transfers the control flow to it. The OS kernel is running. The OS performs other (higher-level) hardware initialization functions, loads the drivers and the user configuration and launches few programs.\n"}),a.add({id:7,href:'/sects/boot-sector/x86/',title:"x86",section:"Sects",content:"The x86 processors #  Now we\u0026rsquo;ll talk about the x86 processors.\nThe 8086 processor had 16-bit data bus and 20-bit address bus. All x86 processors start in the real mode, that basically restricts the operands to 16 bits and the address bus to 20 bits, making the processor compatible with 8086.\nThe general purpose registers are the registers that can be used for most operations by the processor are AX, BX, CX, DX, SI (source index), and DI (destination index). All of these registers are 16 bits wide.\n8086 also had two registers for managing the stack: SP (stack pointer) and BP (base pointer).\nThe IP register contained the address of the next instruction to be executed and can not be altered directly. It can only be changed by e.g. performing a jmp instruction.\n   Register Purpose     AX,BX,CX,DX General purpose registers   SI Source index in string operation   DI Destination index in string operations   SP Stack pointer   BP Stack frame base pointer   IP Instruction pointer    The address bus size in 8086 is 20 bits, which allows to address up to 1 Mb of memory. But all the registers are 16 bits wide. Just using the registers the processor would have been able to address 64 Kb of memory. How does the processor address the rest of the memory?\nSegmentation #  The 8086 CPUs have four Segment Registers:\n   Segment Purpose     DS Default data segment   ES Extra segment   CS Code segment   SS Stack segment    When the segment is not specified in x86 instructions, the default segment is chosen: usually DS, for jumps, calls and other \u0026ldquo;code\u0026rdquo; instructions, it\u0026rsquo;s CS, for stack operations its SS.\nSo every address in x86 can be represented by segment:offset pair. In order to obtain the physical address, i.e. what gets onto the address bus, the processor multiplies segment by 16 and adds the offset.\nPhysicalAddress = 16 * segment + offset\r= (segment \u0026lt;\u0026lt; 4) + offset\rThis can be viewed in multiple ways, the easiest is imagining that an extra zero is written beside the segment.\nHowever, there\u0026rsquo;s an interesting feature of this encoding: we can obtain addressess higher than 1 Mb. Let\u0026rsquo;s try converting the address FFFF:FFFF to physical. We get 10ffef, with the extra \u0026ldquo;1\u0026rdquo; bit on the 21-st bit.\nIn 8086 this calculation would have wrapped around and the physical address would have been FFEF. With later processors, the address bus has become bigger, so what they did is they artificially performed the logical AND of the 21st address line with \u0026ldquo;0\u0026rdquo;, so whatever the result was the 21-st bit would have been zero.\nThis is called A20 Gate. A20 stands for 20-th address line (they are counted from zero). Every x86 processor can only access odd megabytes, unless the A20 line is enabled.\nFurther evolution #  8086 processor has evolved into 80186. There weren\u0026rsquo;t many improvements that interest us.\n80186\u0026rsquo;s successor was 80286. That processor introduced protected mode (but it still started in 8086-compatible real mode). Though that protected mode wasn\u0026rsquo;t widely used. 80286 also extended the address bus to 24 bits (16 Mb).\n80386 (later renamed to i386) was the next processor in line. It was the first 32-bit processor in the x86 line. It enhanced the support for multitasking OS.\n80386 also started up in real mode, but it could use 32-bit instructions in that mode, by prefixing instructions with operand size extend prefix byte and address size extend byte.\nConventions #  x86 refers to the Intel processor architecture, that evolved from the Intel 8086 processor.\ni386 refers to x86 processors that are compatible with intel 80386.\n"})})()