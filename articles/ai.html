<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><h1 id=a-declaration-of-a-new-language>A declaration of a new language</h1><h2 id=forward-compatibility>Forward compatibility</h2><p>A lanugage that does not implement forward compatibility upon evolution will create an utter mess from it's ecosystem.<p>Trying to use a library that is implemented for an earlier version of a program but isn't supported in the current one will either result in frustration or some more hacks in the user code. A programmer who has to use a library will have to search through hundred different libraries writen for different versions of language.<p>Therefore it is important that the programs written for a older version of the language will work for a newer version of the language. This is done by never removing functionality from the language.<p>But never removing functionality and adding new functionality means that overtime the language grows with lots of redundant features. It becomes big and unwieldy. This naturally leads to the thought that the first final version of the language has to be carefully designed. Every features must be thought over several times before being added.<p>But this is only a recommendation. No problem actually gets solved. A brand new technology may appear that might require a language to interact in a different way. Or a new operating system now has to be supported, which totally breaks some of the functionality of the language.<p><strong>ai</strong>'s approach to forwards compatibility consists of:<ul><li>Designing a minimal set of languages supported by compiler that isn't dependent on the platform in any way<li>Making the core part of the language as small as possible<li>Making the standard libraries more "functional", less dependent on a platform<li>Everything that changes frequently has to be extended from within a language, not by compiler.</ul><p>Therefore the users of <em>ai</em> can be sure that their programs will be able to be compiled in the future and that the language will not change too much over time.<h2 id=backwards-compatibility>Backwards compatibility</h2><p>Not required. <em>ai</em> is a brand new langauge, there is nothing to be compatible against.<h2 id=talking-to-the-operating-system>Talking to the Operating System</h2><p>A language requires OS in order to talk to the hardware. Reading files, rendering graphics, taking user input and printing text to screen, opening threads, loading a dynamic library are impossible without an OS.<p>Therefore there needs to be a way to communicate to an operating system from within a lanugage.<p>There are two existing approaches to this:<ul><li>Implementing a virtual machine over all supported OS, and making the language talk to that virtual machine<li>Implementing an actual interface to call functions written in another language.</ul><p>Implementing a virtual machine is a no-go for a native language, because it implies performance hit, and performance is one of the major reasons of going native.<p><em>ai</em> will provide users with a way of specifying foreign functions and linking to the libraries containing them.