<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><h1 id=how-to-handle-errors>How to handle errors</h1><p>Maybe you have felt the strange feeling when you're writing a program, that the external data can be wrong and you have no idea what your program should do in that case. Though, it is quite obvious what should happen if the data is correct. What about the <strong>wrong data</strong>?<p>Should you write a bunch of code that somehow manages to keep your program running? If so, how? Should you just print the error message and quit?<p>I'm writing this article to help new programmers understand the answer to this question, because at some point I have been there and I didn't know the answer. A few years later, after working on a compiler for my programming language for a few months, now I think I have come up with a decent understanding of that problem and I am able to share it.<p>A lot of modern software that I happen to use does not handle errors <strong>in a sensible way</strong> and as a consequence the users, are suffering. Proper error handling and reporting is important to many applications of the programming. Therefore programmers must be aware that the solutions to the problem of handling errors make significant impact on the software they write. In particular programs that handle the errors correctly are more reliable.<p>The answer to the question of what should happen when the external data is wrong is the one answered by the topic of <em>error handling</em> and this is what we will discuss in this article. The prerequisites to reading this article are having prior programming experience in one or more programming languages and being able to read algorithms written in arbitrary language. I will resort to the C syntax when the details matter, otherwise the syntax is arbitrary.<p>The topic of error handling should not be taken lightly for it is not an easy problem. Not because it is a technically hard problem, no. It's hard for several reasons, actually:<ul><li>For one, because there are many ways of handling and reporting the errors. And it's also easy to chose one that makes your program unreliable and the users angry.<li>Secondly, it takes a big amount of knowledge about the real world, specifically the kinds of errors that may occur during various operations. Do you know <strong>all</strong> the reasons the operation of reading of a file may fail?<li>Thirdly, errors <strong>break the flow of control</strong>. The errors follow different codepaths. Therefore adding error handling to an existing program may present a challenge.</ul><p>With that understanding let us proceed to the main part of this article. We will discuss the philosophy and methods of error handling.<p>First let me make clear that errors appearing due to external data doesn't always mean the errors in the data itself, but rather with the fact that we don't know for certain whether the desired computations performed on it at all. For example consider the following program:<pre><code class="c language-c">int a = get_int_from_user("enter the first number: ");
int b = get_int_from_user("enter the second number: ");
int c = a / b;
print("the result of division is: ", c);
</code></pre><p>It's a pretty simple program that divides one number by another. The most obvious possible error in this code happens when user inputs <code>0</code> as the second number, i.e. <code>b</code>.<p>What will happen in that case is CPU will trigger an exception because it can not divide by zero, and since our program (most likely) doesn't have exception handlers set up, the operating system will kill the process of our program. So basically our program will shut down silently, or "crash".<p>If this code is a console application crashing silently may be an acceptable option. However in case of GUI programs and more serious console applications you must think more about what you should do when <code>b</code> is zero.<p>A trivial error handling could the following:<pre><code class="c language-c">if b != 0 {
  int c = a / b;
  print("the result of division is: ", c);
}
</code></pre><p>This changes pretty much nothing in the console applications. At least GUI apps do not crash now. Nor they display the result. Imagine putting <code>1/0</code> in your calculator and seeing nothing happen. Pressing the <code>=</code> button will pretty much do nothing. Sometimes that is good enough. Sometimes you don't want to spam your program with useless error messages and makes the program that works when the data is correct.<p>But sometimes you have to make sure the user knows that something has gone wrong. The user is the one who supplied data, and in bigger programs with thousand of ways to supply data the user will left with nothing if the error occurs.<p>In such cases you have to <strong>provide specific information</strong> about the error. Note the emphasis. It shouldn't just state the fact that an error happened, but <strong>help user fix the data</strong>. Printing the information about what the error is is sufficient for the current example, so our programs becomes this:<pre><code class="c language-c">int a = get_int_from_user("enter the first number: ");
int b = get_int_from_user("enter the second number: ");
if b != 0 {
  int c = a / b;
  print("the result of division is: ", c);
}
else {
  print("error: division by zero");
}
</code></pre><p>Out 4 lines of code had turned into <code>~7</code>. So much effort for the error handling. But if you think about it the only reason we <strong>need</strong> it is because the data is supplied <strong>by the user</strong>, and we don't know whether it is valid prior to executing the program.<p>In fact it would make no sense to write a program like this:<pre><code class="c language-c">int a = 3; // compile-time constant
int b = 0; // compile-time constant
if b != 0 {
  int c = a / b;
  print("the result of division is: ", c);
}
else {
  print("error: division by zero");
}
</code></pre><p>Only imagine user having an error just because <strong>programmer</strong> made a mistake! The user gets the error and there is literally nothing the user can do about it. Just to reiterate: the user should not get the error message if he didn't do anything wrong to receive it.<p>On the other hand if you as a programmer made a mistake you probebly would like to know that it happened. This is where the <code>assert</code> statement/function is useful. This is a function that does <strong>nothing</strong> in a release build, but in debug builds in will crash if and only if the condition supplied to it wasn't fulfilled. Not only crash, some assert implementations also print the location, where that condition has been failed so you have some tools for locating the bug.<p>That is we would like <em>to assert</em> that it is non-zero before executing the division. In C it can be done like this:<pre><code class="c language-c">int a = ...; // value supplied by the programmer
int b = ...; // value supplied by the programmer
assert b != 0;
int c = a/b;
</code></pre><p>The user doesn't have to suffer and get performance penalty for useless error-handling and the programmer has the ability to localize bugs.<p>Note that what I had presented was <strong>not</strong> a progression from the worst error handling methods to the best ones. All methods are equally valid approaches within some contexts. Now I will summarize when each one of the methods is good:<ol><li><strong>No handling</strong> is good when: <ul><li>You're writing a program for no one to use and you don't care about testing for bugs<li>Crashing is fine<li>For some reason you want to write an unreliable program</ul><li><strong>Silent avoidance</strong> is good when: <ul><li>Crashing is not fine<li>You don't want to notify the user about the error</ul><li><strong>Error reporting</strong> is good when: <ul><li>Crashing is not fine<li>The user has to know about invalid data<li>It's fine to waste performance on the correctness checks (you probably want to make <em>this</em> tradeoff 97% of the time)</ul><li><strong>Assertions</strong> are good when: <ul><li>The data has to be correct in release builds, but may be wrong in test builds</ul></ol><p>We're only getting started. Let's suppose that your program is configurable. To load the settings your program reads a file, e.g. <code>settings.json</code>, parses it and sets all the variables to configure itself. Something like this:<pre><code class="c language-c">file settings_file;
json settings_json;
bool file_loaded = load_file("settings.json", &settings_file);
bool json_parsed = parse_json(settings_file, &settings_json);
program_state = set_state_from_json(settings_json);
</code></pre><p>I have made the two imaginary functions' return value <code>bool</code> signifying whether the operation was successfull or not. We see two obvious places where an error can occur. However the problem is not that simple. Can our application run if the config file wasn't successifully loaded?<p>Well, if we load the default config when the file is loaded then our application can run. However the user may be confused as to why his config file didn't apply. Therefore we also need to print the error message. Note that you have to <strong>at least print the message</strong>. You don't have to rely on the default config if have a reason not to.<p>Our code can be rewritten as the following:<pre><code class="c language-c">file settings_file;
json settings_json;
bool file_loaded = load_file("settings.json", &settings_file);
if file_loaded {
  bool json_parsed = parse_json(settings_file, &settings_json);
  if json_parsed {
    program_state = set_state_from_json(settings_json);
  }
  else {
    program_state = default_state;
    print_error("the config file '", filename, "' could not be parsed.\n",
                "Invalid format.");
  }
}
else {
  program_state = default_state;
  print_error("the config file '", filename, "' could not be loaded.\n",
              "Either unaccessible or does not exist.");
}
</code></pre><p>There are couple observations to be made. First, whatever branch is taken, <code>program_state</code> is set to a valid config. We can put this into <code>assert</code>, to make sure that correct parsing implies correct state and that <code>default_state</code> is indeed correct:<pre><code class="c language-c">assert state_is_valid(program_state);
</code></pre><p>The second observation is that the error states do provide the error, but in the case of the json parsing we're not providing information <strong>sufficient enough</strong>. Indeed, if two JSON object fields weren't separated by commas we could provide information about the location in the file (line and column) of the second field from the pair.<p>Sometimes we can not check for every possible error from outside of <code>parse_json</code> function. We will probably need to modify the function in such a way that it fills three fields of the <code>json</code> struct on error: the error location (line and col) and the error message. The json struct can therefore look like this:<pre><code class="c language-c">struct json {
  int err_line;
  int err_col;
  char *err_msg;
  ...
}
</code></pre><p>And we can report the error like this:<pre><code class="c language-c">print_error("The config file '", filename, "' could not be parsed.\n  ",
                json.err_line, ",", json.err_col, ": ", json.err_msg);
</code></pre><p>This code can print an error message kind of like the following:<pre><code>The config file 'config\settings.json' could not be parsed.\n
  123,23: expected ',' got TOKEN
</code></pre><p>Not the best error message, but better than nothing. In fact you can take extra care to make the error messages nicer. However the tradeoff is that sometimes you only know <em>what</em> is wrong and not <em>why</em> it is. From JSON grammar standpoint you know that comma has to follow every field in an object. The parser sees an identifier instead of comma, and that is the precise reason why the error message has the form that it has.<p>However saying what the error is is not always enough. If we can, we should provide the reason why it happened. In this case we know for certain that commas happen in one context, that is separation of objects and therefore we can make the error message look like the following:<pre><code>The config file 'config\settings.json' could not be parsed.\n
  123,23: The objects have to be separated by commas (',')
</code></pre><p>Make sure that you don't do this for the errors that do not have a single reason. If you get the reason wrong, the user may be left confused.<p>The other thing we may want to do is to make it so that if the value is specified incorrectly <strong>only that value</strong> gets reset to default. One thing we could do is rewrite JSON parser in such a way that it returns special <code>invalid_value</code> nodes. If <code>set_state_from_json</code> encounters such node it loads default value instead and reports a corresponding error instead.<p>In this example we can clearly see how we can do something in order to make the error handling a little bit nicer.