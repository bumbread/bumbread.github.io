<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><h1 id=the-language-specification>The language specification</h1><p>Notation:<ol><li><strong>bold</strong> - common programming terminology and emphasis<li><em>italics</em> - language-specific terms used in this document</ol><h2 id=1-lexical-syntax>1. Lexical syntax</h2><h3 id=12-the-source-encoding>1.2. The source encoding</h3><ol><li>File is encoded using <strong>utf-8</strong><li>The text is not canonicalized<li>The symbols above ASCII range can only appear in string literals, char literals and comments<li>The identifiers are case-sensitive<li><strong>NUL</strong> can only appear at the end of the file<li><strong>BOM</strong> can only appear at the start of the file</ol><pre><code class="ebnf language-ebnf">any-char = "\u+01".."\u+10ffff"
</code></pre><h3 id=13-lexemes>1.3. Lexemes</h3><ol><li>The source code is represented by sequence of <strong>lexemes</strong> (<strong>tokens</strong>)<li>Lexeme categories: <ul><li><a href=#132-comments><em>Comments</em></a><li><a href=#134-integer-literals><em>Integer literals</em></a><li><a href=#135-float-literals><em>Float literals</em></a><li><a href=#136-character-literals><em>Character literals</em></a><li><a href=#137-string-literals><em>String literals</em></a><li><a href=#138-boolean-literals><em>Boolean literals</em></a><li><a href=#139-pointer-literal><em>Pointer literal</em></a><li><a href=#1310-identifiers><em>Identifiers</em></a><li><a href=#1311-special-symbols><em>Special symbols</em></a><li><a href=#14-keywords><em>Keywords</em></a></ul><li>The language is a <strong>free-form</strong> language.</ol><h4 id=131-whitespace>1.3.1. Whitespace</h4><p>The following characters are considered to be <strong>whitespace characters</strong>.<ul><li><code>u+0009</code> (horizontal tab)<li><code>u+000a</code> (line feed)<li><code>u+000d</code> (carriage return)<li><code>u+0020</code> (space)</ul><p><strong>Line terminators</strong> are the symbols that terminate the line comments.<p><strong>Line characters</strong> are the characters that don't terminate the line comments.<p>Syntax:<pre><code class="ebnf language-ebnf">whitespace      = "\u+09" | "\u+0a" | "\u+0d" | "\u+20"
line-terminator = "\u+0a" | "\u+0a" "\u+0d"
line-char       = any-char except "\u+0a"
</code></pre><h4 id=132-comments>1.3.2. Comments</h4><p>The language supports three kinds of comments:<ul><li>Line comments<li>Block comments<li>Nesting block comments</ul><p>Syntax:<pre><code class="ebnf language-ebnf">lc-first-char  = any-char  except "#" | "*" | line-terminator
line-comment   = "#" lc-first-char {line-char} (line-terminator | EOF)

bc-marker     = "##"
bc-char       = (any-char except "#") | ("#" (any-char except "#"))
block-comment = bc-marker {bc-char} bc-marker

nbc-start     = "#*"
nbc-end       = "*#"
nbc-char      = (any-char except "*") | ("*" (any-char except "#")) | nb-comment
nb-comment    = nbc-start {nbc-char} nbc-end
</code></pre><h4 id=133-escape-sequences>1.3.3. Escape sequences</h4><p>Escape sequences appear in <a href=#136-character-literals><em>character literals</em></a> and in <a href=#137-string-literals><em>string literals</em></a>.<p>The list of escape sequences:<ul><li><code>\t</code> - horizontal tab symbol, maps to <code>\u+09</code><li><code>\n</code> - line feed symbol, maps to <code>\u+0a</code><li><code>\"</code> - the quotation mark, maps to <code>\u+22</code><li><code>\'</code> - the apostrophe symbol, maps to <code>\u+27</code><li><code>\\</code> - the backslash symbol, maps to <code>\u+5c</code><li><code>\u</code> - the unicode codepoint. 6 hex characters<li><code>\x</code> - the hex codepoint. 4 hex characters<li><code>\a</code> - the ascii codepoint. 2 hex characters</ul><ol><li><p>All other sequences starting with backslash are invalid. The compiler throws an error if it encounters such a sequence.<li><p>The <code>\'</code> and <code>\"</code> backslash sequences are available in either string literals or character literals.</ol><p>Syntax:<pre><code class="ebnf language-ebnf">hex-digit       = "0".."9" | "a".."f" | "A".."F"

backslash       = "\u+5C"
double-quote    = "\u+22"

escape-char     = "t" | "n" | "'" | backslash | double-quote
unicode-cp      = "u" hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit
hex-cp          = "x" hex-digit hex-digit hex-digit hex-digit
ascii-cp        = "a" hex-digit hex-digit
escape-sequence = backslash (escape-char | unicode-cp | hex-cp | ascii-cp)
</code></pre><h4 id=134-integer-literals>1.3.4. Integer literals</h4><p>The language supports four flavours of the integer literals:<ul><li>Binary literals<li>Octal literals<li>Decimal literals<li>Hex literals</ul><ol><li>The integer literal can optionally contain underscores.<li>The integer literal can not start with an underscore<li>the underscore can not appear within the prefixes.<li>In literals with the base greater than 10 the case of characters is ignored.</ol><p>Syntax:<pre><code class="ebnf language-ebnf">bin-digit   = "0".."1" | "_"
bin-prefix  = "0b" | "0b"
bin-literal = bin-prefix {bin-digit}

oct-digit   = "0".."7" | "_"
oct-prefix  = "0o" | "0O"
oct-literal = oct-prefix {oct-digit}

dec-start   = "0".."9"
dec-digit   = "0".."9" | "_"
dec-prefix  = "0d" | "0D"
dec-literal = (dec-prefix | dec-start) {dec-digit}

hex-digit   = "0".."9" | "a".."f" | "A".."F" | "_"
hex-prefix  = "0x" | "0X"
hex-literal = hex-prefix {hex-digit}

int-literal = bin-literal | oct-literal | dec-literal | hex-literal
</code></pre><h4 id=135-float-literals>1.3.5. Float literals</h4><ol><li>The floating point literals are <strong>required</strong> to contain the <code>"."</code> (dot) symbol. In general, the floating point literal can be represented as<li>It is <strong>required</strong> to have at least one whole digit, one fractional digit, and if the exponent part exists, one exponent digit (<code>_</code> is also a digit).<li>The compiler supports two flavors of the floating-point numbers: <ul><li>decimal floating point numbers<li>hex floating-point numbers</ul><li>In the case of decimal floating point numbers, the exponent part is required to start with <strong>e</strong> or <strong>E</strong><li>In the case of hex floating point numbers, the exponent part is required to start with <strong>p</strong> or <strong>P</strong>. The exponent is considered to be a <em>binary exponent</em>.<li>There are two special floating point literals: <code>nan</code> and <code>inf</code>.</ol><p>The formal syntax is as follows:<pre><code class="ebnf language-ebnf">dec-prefix = "0d" | "0D"
dec-start  = "0".."9"
dec-digit  = "0".."9" | "_"
dec-whole  = (dec-prefix | dec-start) {dec-digit}
dec-fract  = {dec-digit}
dec-exp    = {dec-digit}
dec-float  = dec-whole "." dec-fract [("e" | "E") ["+" | "-"] dec-exp]

hex-prefix = "0x" | "0X"
hex-digit  = "0".."9" | "a".."f" | "A".."F" | "_"
hex-whole  = hex-prefix {hex-digit}
hex-fract  = {hex-digit}
bin-exp    = {hex-digit}
hex-float  = hex-whole "." hex-fract [("p" | "P") ["+"|"-"] bin-exp]

float-literal = dec-float | hex-float | "nan" | "inf"
</code></pre><h4 id=136-character-literals>1.3.6. Character literals</h4><ol><li>Character literals represent integer values for unicode codepoints<li>The character literal can contain unicode characters above the ASCII range.</ol><pre><code class="ebnf language-ebnf">apostrophe  = "\u+2d"
backslash   = "\u+5c"
char-symbol = any-char except apostrophe | backslash | line-terminator

char-literal = apostrophe (char-symbol | escape-sequence) apostrophe
</code></pre><h4 id=137-string-literals>1.3.7. String literals</h4><p>String literals contain sequence of unicode characters<pre><code class="ebnf language-ebnf">quote-mark  = "\u+22"
backslash   = "\u+5c"
str-symbol  = any-char except quote-mark | backslash | line-terminator

str-literal = quote-mark {str-symbol | escape-sequence} quote-mark
</code></pre><h4 id=138-boolean-literals>1.3.8. Boolean literals</h4><p>There are two boolean literals: <code>true</code> and <code>false</code>.<pre><code class="ebnf language-ebnf">bool-literal = "true" | "false"
</code></pre><h4 id=139-pointer-literal>1.3.9. Pointer literal</h4><p>There is only one pointer literal: <code>nil</code>.<pre><code class="ebnf language-ebnf">ptr-literal = "nil"
</code></pre><h4 id=1310-identifiers>1.3.10. Identifiers</h4><ol><li><em>Identifiers</em> represent user-defined names and <em>keywords</em>. The identifiers may only contain ASCII letters, underscores and digits.<li>Identifiers are not allowed to start with a digit.</ol><p>Syntax:<pre><code class="ebnf language-ebnf">identifier-start = "_" | "a".."z" | "A".."Z"
identifier-char  = "_" | "a".."z" | "A".."Z" | "0".."9"
identifier       = identifier-start {identifier-char}
</code></pre><h4 id=1311-special-symbols>1.3.11 Special symbols</h4><ol><li>Each of the following sequences is parsed by the lexer as being a single token.<li>The parser tries to parse the longest sequence from this list.</ol><pre><code class="ai language-ai">+   +=   ~   ~=   $   <    &LT-   (    )
-   -=   |   |=   @   >    ->   [    ]
*   *=   &   &=   !   <=   ,    {    }
/   /=   <<  <<=  ?   >=   .    ;
%   %=   >>  >>=  ==  !=   :    ..
</code></pre><h3 id=14-keywords>1.4 Keywords</h3><ol><li>Keywords are special types of <em>identifiers</em>.<li><code>_</code>, <code>this</code>, <code>nan</code>, <code>inf</code>, <code>false</code>, <code>true</code> and <code>nil</code> are <strong>not keywords</strong>.</ol><p>The keywords and their meanings:<table><thead><tr><th>keyword<th>meaning<tbody><tr><td><code>and</code><td>boolean and operator<tr><td><code>or</code><td>boolean or operator<tr><td><code>xor</code><td>boolean xor operator<tr><td><code>iff</code><td>boolean equivalence operator<tr><td><code>implies</code><td>boolean implication operator<tr><td><code>not</code><td>boolean negation operator<tr><td><code>sizeof</code><td>sizeof operator<tr><td><code>typeof</code><td>typeof operator<tr><td><code>offsetof</code><td>offsetof operator<tr><td><code>if</code><td><strong>if</strong> statement<tr><td><code>else</code><td><strong>else</strong> branch<tr><td><code>while</code><td><strong>while</strong> statement<tr><td><code>do</code><td><strong>do</strong> inline block<tr><td><code>repeat</code><td><strong>repeat</strong> statement<tr><td><code>until</code><td><strong>until</strong> condition of <strong>repeat</strong> statement<tr><td><code>try</code><td><strong>try-catch</strong> block<tr><td><code>catch</code><td><strong>catch</strong> clause<tr><td><code>let</code><td>variable declaration<tr><td><code>type</code><td>type declaration<tr><td><code>func</code><td>func declaration and func type<tr><td><code>meth</code><td>method declaration<tr><td><code>oper</code><td>operator declaration<tr><td><code>struct</code><td><strong>struct</strong> declaration and struct type<tr><td><code>enum</code><td><strong>enum</strong> declaration and enum type<tr><td><code>union</code><td><strong>union</strong> declaration and union type<tr><td><code>print</code><td>print statement<tr><td><code>assert</code><td>assert statement<tr><td><code>break</code><td>break statement<tr><td><code>continue</code><td>continue statement<tr><td><code>return</code><td>return statement<tr><td><code>throw</code><td>throw statement<tr><td><code>import</code><td>import file<tr><td><code>namespace</code><td>namespace scope<tr><td><code>private</code><td>private to file scope</table><h2 id=2-code-structure>2. Code structure</h2><h3 id=21-expression-syntax>2.1. Expression syntax</h3><h4 id=211-operators>2.1.1. Operators</h4><p>Unary operators:<table><thead><tr><th>Sign<th>Operation name<tbody><tr><td><code>$</code><td>Addressof<tr><td><code>@</code><td>Dereference<tr><td><code>-</code><td>Negate<tr><td><code>~</code><td>Bitwise negation<tr><td><code>not</code><td>Logical negation<tr><td><code>[N]</code><td>Subscript<tr><td><code>[N:M]</code><td>Subslice<tr><td><code>(...)</code><td>Function call</table><p>Binary operators:<table><thead><tr><th>Sign<th>Operation name<tbody><tr><td><code>+</code><td>Sum<tr><td><code>-</code><td>Difference<tr><td><code>*</code><td>Product<tr><td><code>/</code><td>Divide<tr><td><code>%</code><td>Modulo<tr><td><code>&</code><td>Bitwise and<tr><td><code>|</code><td>Bitwise or<tr><td><code>~</code><td>Bitwise not<tr><td><code><<</code><td>Shift up<tr><td><code>>></code><td>Shift down<tr><td><code>></code><td>Greater<tr><td><code><</code><td>Less<tr><td><code>>=</code><td>No-less<tr><td><code><=</code><td>No-Greater<tr><td><code>==</code><td>Equal<tr><td><code>!=</code><td>Not equal<tr><td><code>:</code><td>Cast<tr><td><code>::</code><td>Transmute<tr><td><code>and</code><td>Logical and<tr><td><code>or</code><td>Logical or<tr><td><code>xor</code><td>Logical xor<tr><td><code>implies</code><td>Logical implication<tr><td><code>iff</code><td>Logical equivalence<tr><td><code>,</code><td>Tuple element sep</table><p>Binary assignment operators:<table><thead><tr><th>Sign<th>Operation name<tbody><tr><td><code>=</code><td>Assign<tr><td><code>+=</code><td>Add<tr><td><code>-=</code><td>Subtract<tr><td><code>*=</code><td>Multiply by<tr><td><code>/=</code><td>Divide by<tr><td><code>%=</code><td>Assign remainder<tr><td><code>&=</code><td>And with<tr><td><code>|=</code><td>Or with<tr><td><code>~=</code><td>Xor with<tr><td><code>>>=</code><td>Shift down<tr><td><code><<=</code><td>Shift up</table><pre><code class="ebnf language-ebnf">unary-op  = "$"   | "@"   | "-"   | "~"  | "[]"  | "[:]"

binary-op = "+"   | "*"   | "/"   | "%"   | "&"   | "|"   | "<<" 
          | ">>"  | ">"   | "<"   | ">="  | "<="  | "=="  | "!="
          | "not" | "and" | "or"  | "xor" | "iff" | "implies" 

assign-op = "="   |  "+=" | "*="  | "/="  | "%="  | "&=" | "|="
          | "<<=" | ">>=" | ">="  | "<="  | "[]=" | "[:]="


operator  = "$"   | "@"   | "-"   | "~"  | "[]"  | "[:]" | "()"
          | "+"   | "*"   | "/"   | "%"  | "&"   | "|"   | "<<" 
          | ">>"  | ">"   | "<"   | ">=" | "<="  | "=="  | "!="
          | "="   | "not" | "and" | "or" | "xor" | "iff" | "implies" 
</code></pre><h4 id=212-operator-precedence>2.1.2. Operator precedence</h4><ol><li>Postfix unary operators have higher precedence than prefix unary operators.<li>The precedence table for the binary operators:</ol><table><thead><tr><th>Precedence<th>Group name<th>Operators<tbody><tr><td>7<td>Product-like<td><code>&</code>, <code><<</code>, <code>>></code>,<code>*</code>, <code>/</code>, <code>%</code><tr><td>6<td>Sum-like<td><code>|</code>, <code>~</code>,<code>+</code>, <code>-</code><tr><td>5<td>Relational<td><code>==</code>, <code>!=</code>, <code>></code>, <code><</code>, <code>>=</code>, <code><=</code><tr><td>4<td>Boolean and<td><code>and</code><tr><td>3<td>Boolean or-like<td><code>or</code>,<code>xor</code><tr><td>2<td>Boolean relational<td><code>iff</code>, <code>implies</code><tr><td>1<td>Type conversions<td><code>:</code>, <code>::</code><tr><td>0<td>Assignment<td><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&=</code>, <code>|=</code>, <code>~=</code>, <code>>>=</code>, <code><<=</code></table><h4 id=213-expressions-syntax>2.1.3. Expressions syntax</h4><pre><code class="ebnf language-ebnf">literal      = int-literal 
             | float-literal
             | char-literal
             | bool-literal
             | ptr-literal
             | string-literal
             | identifier

call-params  = "(" [expression { "," expression }] ")"
subscript    = "[" (expression | ([expression] ":" [expression]) ) "]"

postfix-op   = "$" | call-params | subscript
prefix-op    = "-" | "~" | "@"

op-prod      = "&"  | "<<" | ">>" | "*" | "/" | "%"
op-sum       = "|"  | "~"  | "+"  | "-"
op-rel       = "==" | "!=" | ">"  | "<" | ">=" | "<="
op-b-and     = "and"
op-b-or      = "or" | "xor"
op-b-rel     = "iff" | "implies"
op-type      = ":" | "::"
op-ass       = "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "~=" | "&=" | "|="

expr-lit     = literal
             | "(" expression ")"

expr-postfix = expr-lit { postfix-op }
expr-prefix  = expr-postfix
             | prefix-op expr-prefix

expr-prod    = expr-prefix { op-prod  expr-prefix }
expr-sum     = expr-prod   { op-sum   expr-prod   }
expr-rel     = expr-sum    { op-rel   expr-sum    }
expr-b-and   = expr-rel    { op-b-and expr-rel    }
expr-b-or    = expr-b-and  { op-b-or  expr-b-and  }
expr-b-rel   = expr-b-or   { op-b-rel expr-b-or   }
expr-type    = expr-b-rel  { op-type  expr-b-rel  }
expr-tuple   = expr-type   { ","      expr-type   }
expr-ass     = expr-tuple  { op-ass   expr-tuple  }

expression   = expr-ass
</code></pre><h3 id=22-type-syntax>2.2. Type syntax</h3><h4 id=211-primitive-types>2.1.1. Primitive types</h4><ol><li><em>basic types</em> define the types natively supported by the compiler<li><em>primitive types</em> define the single-identifier types<li><em>simple types</em> define primitive types and slices, arrays or pointers to other simple types.</ol><p>Syntax:<pre><code class="ebnf language-ebnf">basic-type = "bool"  | "b8" | "b16" | "b32" | "b64"
           | "int"   | "i8" | "i16" | "i32" | "i64"
           | "uint"  | "u8" | "u16" | "u32" | "u64"
           | "rune"  | "r8" | "r16" | "r32" | "r64"
           | "float"                | "f32" | "f64"
           | "ptr"                          | "p64"

prim-type  = basic-type
           | identifier
</code></pre><p>Default sizes:<pre><code class="ai language-ai">bool  = bool(1)
int   = int(8)
float = float(8)
ptr   = ptr(8)
</code></pre><h4 id=212-pointer-types>2.1.2. Pointer types</h4><pre><code class="ebnf language-ebnf">ptr-type     = simple-type "$" 
</code></pre><h4 id=213-array-types>2.1.3. Array types</h4><pre><code class="ebnf language-ebnf">array-type   = simple-type "[" int-literal "]"
</code></pre><h4 id=214-slice-types>2.1.4. Slice types</h4><pre><code class="ebnf language-ebnf">slice-type   = simple-type "[" "]"
</code></pre><h4 id=215-function-types>2.1.5. Function types</h4><pre><code class="ebnf language-ebnf">type-list    = "(" type {"," type} ")"
type-mapping = type-list [ "->" (simple-type | type-list) ]
func-type    = "func" type-mapping
</code></pre><h4 id=216-struct-types>2.1.6. Struct types</h4><ol><li>Structs can contain <em>functions</em>, <em>methods</em> and <em>operator overloads</em>.<li>The declarations inside a struct can be separated by either <code>,</code> or <code>;</code></ol><p>Syntax:<pre><code class="ebnf language-ebnf">sep          = ";" | ","

func-decl    = iden {"," iden} ":" type
func-decls   = func-decl {"," func-decl}
func-tuple   = "(" [func-decls] ")"
func-mapping = func-tuple ["->" func-tuple]

iden-list    = identifier {"," identifier}
struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier func-mapping "{" stmt-list "}" [sep]
struct-oper  = "oper" operator   func-mapping "{" stmt-list "}" [sep]

struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl

struct-body  = "{" struct-decls "}"
struct-type  = "struct" struct-body
</code></pre><h4 id=217-union-types>2.1.7. Union types</h4><ol><li>Unions can contain <em>functions</em>, <em>methods</em> and <em>operator overloads</em>.<li>The declarations inside a struct can be separated by either <code>,</code> or <code>;</code>.</ol><pre><code class="ebnf language-ebnf">sep          = ";" | ","

func-decl    = iden {"," iden} ":" type
func-decls   = func-decl {"," func-decl}
func-tuple   = "(" [func-decls] ")"
func-mapping = func-tuple ["->" simple-type | func-tuple]

iden-list    = identifier {"," identifier}
union-field  = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
union-func   = "func" identifier func-mapping "{" stmt-list "}" [sep]
union-meth   = "meth" identifier func-mapping "{" stmt-list "}" [sep]
union-oper   = "oper" operator   func-mapping "{" stmt-list "}" [sep]

union-decl   = union-field | union-func | union-meth
last-decl    = last-field  | union-func | union-meth
union-decls  = { union-decl } last-decl

union-body   = "{" union-decls "}"
union-type   = "union" union-body
</code></pre><h4 id=218-enum-types>2.1.8. Enum types</h4><p>Enumeration types represent a finite set of values with integers assigned to each of them.<pre><code class="ebnf language-ebnf">sep          = ";" | ","

enum-decl    = identifier ["=" int-literal]
enum-decls   = enum-decl {sep enum-decl}
enum-type    = "enum" "{" enum-decls "}"
</code></pre><h3 id=23-statement-syntax>2.3. Statement syntax</h3><h4 id=331-expression-statements>3.3.1. Expression statements</h4><pre><code class="ebnf language-ebnf">expr-stmt = expr ";"
</code></pre><h4 id=232-variable-declarations>2.3.2. Variable declarations</h4><p>If <code>type</code> was not specified, the initialization is <strong>required</strong>.<pre><code class="ebnf language-ebnf">vars      = identifier ["," identifier] [":" type]
decl-list = vars {"," vars}
let-decl  = "let" decl-list ["=" expr] ";"
</code></pre><h4 id=233-function-declarations>2.3.3. Function declarations</h4><ol><li>The functions can be declared anywhere in the code.<li>Non-extern function declarations are <strong>required</strong> to have a body.<li>At the end of the function declaration the semicolon is optional.</ol><pre><code class="ebnf language-ebnf">func-mapping = "(" decls ")" "->" simple-type

func-decl    = ["extern"] "func"
               identifier func-mapping "{" stmt-list "}" [";"]
</code></pre><h4 id=234-type-declarations>2.3.4. Type declarations</h4><pre><code class="ebnf language-ebnf">sep          = ";" | ","

func-decl    = iden {"," iden} ":" type
func-decls   = func-decl {"," func-decl}
func-tuple   = "(" [func-decls] ")"
func-mapping = func-tuple ["->" simple-type | func-tuple]

iden-list    = identifier {"," identifier}
union-field  = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
union-func   = "func" identifier func-mapping "{" stmt-list "}" [sep]
union-meth   = "meth" identifier func-mapping "{" stmt-list "}" [sep]
union-oper   = "oper" operator   func-mapping "{" stmt-list "}" [sep]

type-decl    = union-field | union-func | union-meth
last-decl    = last-field  | union-func | union-meth
type-decls   = { union-decl } last-decl

type-body    = "{" type-decls "}"

type-decl = "type" identifier "=" type [type-body] ";"
</code></pre><h4 id=235-if-statement>2.3.5. If statement</h4><p>If statement lets conditionally execute some code, depending on some part of the state of the program.<pre><code class="ebnf language-ebnf">stmt-body = "{" stmt-list "}" | "do" stmt | ";"
with-decl = "with" decl-list ["=" expression] ";"
if-stmt   = "if" [with-decl] expr stmt-body
             [ "else" (stmt-body | stmt) ]
</code></pre><p>Unlike C-like languages, <strong>0</strong> doesn't require parenthesis around expressions. As a tradeoff the brackets around the statement list are required, unless <code>do</code> keyword is used.<p>If several <em>inline if</em> statements are chained, one inside another, the <code>else</code> block becomes part of the inner-most <code>if</code> statement.<p>Here's a list of examples:<pre><code class="ai language-ai">if a>10 {
  print "karamba!";
}

if a>10 do print "karamba!";

if a>10 do { print "karamba"; }

if a>10 do
   if b>10 do
      if c>10 do print "ha!"
      else print "hey :(";
   else print "ok";
else print "ok";

if f();

if with file_handle,ok = load_file("file.txt"); ok {
  # ...
}
</code></pre><h4 id=336-while-statement>3.3.6. While statement</h4><p>While statements let the program repeat execution of a certain statement block <em>zero or more times</em> based on the program's state.<p>The syntax of while loops is the following:<pre><code class="ebnf language-ebnf">stmt-body  = "{" stmt-list "}" | "do" stmt | ";"
with-decl  = "with" decl-list ["=" expression] ";"
while-stmt = "while" [with-decl] expr stmt-body
</code></pre><p>Examples:<pre><code class="ai language-ai">while a&LT10 {
  print a;
  a += 1;
}

while a&LT10 do a+=1;

while state && f(state$);

while with i=0; i != 100 {
  print i;
  i += 1;
}
</code></pre><h4 id=338-repeat-statement>3.3.8. Repeat statement</h4><p>Repeat statements let program repeat execution of a certain statement block <em>one or more times</em>.<p>The syntax for repeat statements is the following:<pre><code class="ebnf language-ebnf">with-decl = "with" decl-list ["=" expression] ";"
repeat-stmt = "repeat" [with-decl] stmt-list "until" expr ";"
</code></pre><p>Examples:<pre><code class="ai language-ai">repeat
  a += 3;
  print a;
until a>=100;

repeat {
  a += 1;
  print a;
} until a>=100;

repeat a+=1; until a>=100;

repeat with i=0 {
  i += 1;
  print i;
} until i == 100;
</code></pre><h4 id=337-flow-control-statements>3.3.7. Flow control statements</h4><p>The <code>break</code> statements jumps out of any loop. Thus it can be used only within loops.<p>The <code>continue</code> statement jumps to the code that evaluates the condition thereby advancing the loop to one more execution. This statement also can only be used within loops.<p>The <code>return</code> statement returns an expression from the function scope. And jumps back to the code that called the function. The <code>return</code> statement can only be used within function and method bodies.<pre><code class="ebnf language-ebnf">break-stmt    = "break" ";"
continue-stmt = "continue" ";"
return-stmt   = "return" [expr] ";"
</code></pre><p>Example:<pre><code class="ai language-ai">func min(s: int[])->int {
  let m: int = s[0];
  let i: int = 1;
  while i&LTs.len do if s[i]>m {
    m = s[i];
    break;
  }
  return m;
}

func nop() {
  return;
}
</code></pre><h4 id=338-block-statements>3.3.8. Block statements</h4><p>Block statements let you group several statements into one and introduce a <em>scope</em>.<pre><code class="ebnf language-ebnf">stmt-list  = {stmt}
block-stmt = "{" stmt-list "}"
</code></pre><p>Example:<pre><code class="ai language-ai">{
  let x: int = 0;
  let y: int = 2;
  {
    # x and y are accessible here
    if x>y do print "a";

    {
      # x and y are still accessible
      let z: int = x+y;
      # and now z is also accessible
      if z>x do print z;
    }

    # z is inaccessible anymore, but x and y are
    print x-y;
  }


}
</code></pre><h3 id=24-program-structure>2.4. Program structure</h3><p>The source code structure of <strong>0</strong> represets a list of statements. Whenever the <strong>0</strong> program is compiled and then executed, conceptually the execution starts from the very first statement of the program. Unlike most other procedural and object-oriented programming languages, <strong>0</strong> does not require an execution entry point.<p>Therefore<pre><code class="ai language-ai">let x: int = 3;
while x < 10 {
  x += 1;
}

print x;
</code></pre><p>Is a valid <strong>0</strong> program.`