<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><p>﻿<h1>X language specification</h1><p>This is a specification for a language called <strong>X</strong> developed by <a href=https://github.com/bumbread/>bumbread</a>. This document covers all the details about the syntax, semantics and behaviour of the language.<p>In particular, it will be useful for:<ul><li>Compile writers, who wish to correctly implement the language compilation<li>People, who write syntax files for their editors' token highlighters<li>The people interested in the basic set of features of the language.<li>The <strong>X</strong> language programmers.</ul><p>This document does not cover quick guide to the basic syntax and the examples are kept to minimum. Nevertheless each syntax is showcased at least once, so a person interested in knowing how the language looks like can skim through the file.<p>This document comments about all the edge cases objectively, without commenting on what the programmer should and shouldn't do. Every strict "shouldn't" was already encompassed in the language's rules.<h2>1. Lexical syntax</h2><h3>1.0 Possible ideas (to be removed)</h3><ul><li>Imaginary literals<li>For loops<li>Unsigned, sized types<li>Multiline comments<li>Conditional compilation</ul><h3>1.1. The notation</h3><p>In order to make the discussion about language's syntax easier and make the definition of syntax more rigorous, I am definiting a <a href=https://en.wikipedia.org/wiki/Formal_grammar>formal grammar</a> notation. This notation is pretty similar to <strong>EBNF</strong>, but it has some minor changes.<p>In that notation, every production rule is written as follows.<pre><code class=language-ebnf>&LTproduction-name> = &LTexpression>
</code></pre><p>At the left-hand side, the name of <strong>production</strong> (containing lowercase ASCII letters, <code>_</code> (underscore), <code>-</code> (dash) and digits) is written. Each rule specifies a replacement syntax. The name on the left-hand side can be replaced with <code>&LTexpression></code> on the right-hand side.<p>An <code>&LTexpression></code> can be a string or other production. Strings are enclosed <code>"</code> (quotation mark) characters. For example, to define the <code>if</code> keyword one could write the following production rule:<pre><code class=language-ebnf>if-keyword = "if"
</code></pre><p><strong>Alternatives</strong> represent set of several possible productions. Exactly one alternative from the set has to be chosen. Alternatives are separated by the <code>|</code> (pipe) symbol. For example, I can define production rule for a vowel as follows:<pre><code class=language-ebnf>vowel = "a" | "i" | "u" | "e" | "o"
</code></pre><p>Sometimes due to aesthetic reasons I will put newline before every <code>|</code> symbol.<pre><code class=language-ebnf>vowel = "a" 
      | "i"
      | "u"
      | "e"
      | "o"
</code></pre><p><strong>Sequences</strong> represent expressions following one by another in order. Expressions can be sequenced by writing them one after another, without separators (unlike <strong>EBNF</strong> the comma isn't used in between expressions). For example, rewriting the earlier <code>if</code> keyword example we could get:<pre><code class=language-ebnf>if-keyword = "i" "f"
</code></pre><p>The sequence "operation" has higher "precedence" than alternative operation. The production for either string <code>"ab"</code> or <code>"cd"</code> can be defined as follows:<pre><code class=language-ebnf>random-string = "a" "b"
              | "c" "d"
</code></pre><p>Sometimes it is useful to make a sequence of alternatives instead. For example if I want to sequence string <code>"a"</code> with either <code>"0"</code> or <code>"1"</code> I could write:<pre><code class=language-ebnf>random-string = "a" ("0" | "1")
</code></pre><p>This is what <strong>grouping</strong> operator is.<p>Besides the normal grouping, this notation also has <strong>repetition</strong> operator that repeats the production finitely many times. To repeat a production enclose it in braces (<code>{}</code>) And <strong>optional</strong> operator that marks certain production as being optional. To mark production as optional enclose it with brackets (<code>[]</code>). For example I could define a grammar for decimal numbers as follows:<pre><code class=language-ebnf>decimal-digit = "0" | "1" | "2" | "3" | "4"
              | "5" | "6" | "7" | "8" | "9"

decimal-number = decimal-digit {decimal-digit}
</code></pre><p>We first define a set of alternatives for <code>decimal-digits</code> to be all digits from <code>"0"</code> to <code>"1"</code>. Then we define <code>decimal-number</code> as at least one decimal digit followed by some amount (or zero) digits.<p>For strings I can specify an <strong>escape sequence</strong>, that will specify unicode codepoint. It has a form of <code>\u+{x}</code>, where <code>x</code> is a hexadecimal character. For example, <code>"\u+30"</code>, <code>"\u+030"</code> and <code>"\u+0030"</code> all mean the same character - <code>"0"</code> (it has unicode codepoint <code>u+0030</code>).<p>Also the <strong>range</strong> operator is used. The syntax looks like <code>"character1".."character2"</code>. It takes single-character strings, and it matches at least one character with codepoint in between codepoint of <code>"character1"</code> up until and including the codepoint of <code>"character2"</code>.<p>For example, the <code>decimal-digits</code> production from before could be written as:<pre><code class=language-ebnf>decimal-digit = "\u+30".."\u+39"
</code></pre><p>Or, alternatively:<pre><code class=language-ebnf>decimal-digit = "0".."9"
</code></pre><p>The formal definition for the grammar using this grammar is therefore:<pre><code class=language-ebnf>decimal-digit = "0".."9"
ascii-letter  = "a".."z" | "A".."Z"
identifier    = { ascii-letter | decimal-digits | "-" | "_" }

ascii-symbol  = "\u+00".."\u+7f"
backslash     = "\u+5c"
hex-digit     = "a".."f" | "A".."F" | "0".."9"
hex-number    = hex-digit | {hex-digit}
string        = "\u+22" (ascii-symbol | backslash "u+" hex-number) "\u+22"

production-rule = identifier "=" alternative
alternatives    = sequence   {"|" sequence  }
sequence        = expression {    expression}
expression      = string
                | identifier
                | "(" alternatives ")"
                | "{" alternatives "}"
                | "[" alternatives "]"
</code></pre><h3>1.2. The source encoding</h3><p>The <strong>X</strong> source file must be represented by a sequence of characters encoded using <strong>utf-8</strong> encoding. Other encodings should not be accepted.<p>The national symbols and other codepoints above ASCII range (<code>"\u+01".."0+7f"</code>) <strong>can only appear inside comments, strings or char literals</strong>.<p>The text is not canonicalized. A codepoint representing decorated letter is different from two codepoints, one for the letter and one for the diacritics. So <code>だ</code> is different from <code>た</code> followed by the dakuten (<code>u+3099</code>) character.<p>In general, the two characters are different if the codepoints representing them are different. That also implies case-sensitivity.<p>The compiler disallows <code>u+0000</code> character anywhere in the source code except the endmost position, where it is ignored. UTF-8 Byte order mask (<code>0xFEFF</code>) is disallowed anywhere in the source except the very first position, where it is ignored.<p>In the following sections a special identifier <code>EOF</code> will be used in the formal grammars. It does not necessarily represents a particular character. But rather it represents "virtual character" representing the end of line.<h3>1.3. Lexemes</h3><p>The source code is represented by sequence of <strong>lexemes</strong>. Lexemes are a higher-order representations of the source code. Lexemes can be one of the following categories:<ul><li>Integer literal<li>String literal<li>Floating-point literal<li>Identifier<li>Special symbol (<code>"("</code>, <code>"$"</code>, <code>">="</code>, et cetera)<li>Comment</ul><h4>1.3.1. Whitespace</h4><p>Any whitespace characters before and after every lexeme are <strong>ignored</strong>. The whitespace characters inside lexemes (e.g. in string literals) are not ignored.<p>The following characters are considered to be <em>whitespace characters</em>.<ul><li><code>u+0009</code> (horizontal tab)<li><code>u+000a</code> (line feed)<li><code>u+000b</code> (vertical tab)<li><code>u+000c</code> (form feed)<li><code>u+000d</code> (carriage return)<li><code>u+0020</code> (space)</ul><p>Formally,<pre><code class=language-ebnf>whitespace = "\u+09".."\u+0d" | "\u+20"
</code></pre><p><strong>X</strong> is a <strong>free-form</strong> programming language. That means that beyong separating lexemes whitespace has no significant role. The meaning of the program stays the same if each whitespace character is replaced with other whitespace character (excluding the ones <em>inside</em> the lexemes, such as string literals (<strong>p.1.3.7</strong>) or comments (<strong>p.1.3.2</strong>).<h4>1.3.2. Comments</h4><p>The <strong>comments</strong> are special kind of lexeme that are discarded by the compiler. However the comments can be parsed by other utilities. <strong>X</strong> only has support for single-line comments.<p>The line comments start with <code>"#"</code> character that is not part of the string or char literal and ends with <code>"\u+0a"</code> (line feed) character, or by the end of file.<p>Formally:<pre><code class=language-ebnf>comment-symbol = "\u+0001".."\u+0009" | "\u+000b".."\u+10ffff"
line-comment   = "#" {comment-symbol} ("\u+000a" | EOF)
</code></pre><p>Examples:<pre><code class=language-x># Hi, this is a comment
# Комментарий на русском
#nospaces
</code></pre><p>The line comments will also be used in the following examples to describe the examples.<h4>1.3.3. Escape sequences</h4><p>In <em>character literals</em> (<strong>p. 1.3.6.</strong>) and in <em>string literals</em> (<strong>p. 1.3.7.</strong>), apart from the raw unicode characters, the user can input a special sequence of characters that would map to a single character.<p>This is made so that some symbols are easier to read or type and sometimes to bypass limitations of the lexer, e.g. not being able to otherwise put <code>"</code> character inside a string literal.<p>The list of escape sequences:<ul><li><code>\t</code> - horizontal tab symbol, maps to <code>\u+09</code><li><code>\n</code> - line feed symbol, maps to <code>\u+0a</code><li><code>\"</code> - the quotation mark, maps to <code>\u+22</code><li><code>\'</code> - the apostrophe symbol, maps to <code>\u+27</code><li><code>\\</code> - the backslash symbol, maps to <code>\u+5c</code><li><code>\u{x}</code> - the unicode codepoint (up to 6 characters)</ul><p>All other sequences starting with backslash are invalid. The compiler throws an error if it encounters such a sequence.<p>The <code>\'</code> and <code>\"</code> backslash sequences are available in either string literals or character literals. The compiler should not treat e.g. <code>\'</code> inside a string literal as an error.<p>Note that the unicode escape sequence maps to the code specified after <code>u</code>. Some examples:<pre><code class=language-x>\u0       # maps to u+0000
\u00      # still maps to u+0000
\u000     # still maps to u+0000
\u0000    # still maps to u+0000
\u00000   # still maps to u+0000
\u000000  # still maps to u+0000
\u0000000 # counts as 2 characters: u+0000 followed by u+0030
\u110000  # invalid, the code point is greater than u+10ffff
</code></pre><h4>1.3.4. Integer literals</h4><p>The integer literals represent constant positive whole numeric values. The values can be specified in a variety of flavors: binary (bin) literals, octal (oct) literals, decimal (dec) literals and finally hexadecimal (hex) literals.<p>The literals in base other than 10 (and <em>optionally</em> in base 10) can be prefixed with special prefix.<ul><li><code>0b</code> and <code>0B</code> are the prefixes for <em>binary</em> literals.<li><code>0o</code> and <code>0O</code> (zero followed by capital o) are the prefixes for <em>octal</em> literals.<li><code>0d</code> and <code>0D</code> are the prefixes for <em>decimal</em> literals.<li><code>0x</code> and <code>0X</code> are the prefixes for <em>hexadecimal</em> literals.</ul><p>The integer literal can optionally contain underscores for visual clarity, e.g. one million can be written as <code>1_000_000</code> or like <code>100_0000</code>. The integer literal can not start with an underscore. The underscore can, however appear anywhere after the first digit or after the prefix. So <code>0b_0</code> is valid.<p>The underscores are ignored. If the only digit after the prefix is the underscore, the value of the literal is <code>0</code>.<p>Here's an example of valid and invalid integer literals<pre><code class=language-x>0          # valid, parsed as 0
00         # valid, parsed as 0
100_0000   # valid, parsed as 1000000
0d_1_000_0 # valid, parsed as 10000
0_         # valid, parsed as 0
0d_        # valid, parsed as 0
0d1F       # invalid, uses hexadecimal digits in decimal value
_1000      # invalid, actually parsed as identifier lexeme
0_d1000    # invalid, underscore is not allowed to break the prefix
</code></pre><p>Whatever the base is, the final parsed value has to be no greater than <code>9223372036854775807</code> (<code>0xFFFF_FFFF_FFFF_FFFF</code>). If the specified value is greater, the compiler produces an error.<p>In hex literals, the case of characters is ignored. <code>0xf</code> and <code>0xF</code> mean the same thing.<p>The formal syntax for integer literals:<pre><code class=language-ebnf>bin-digit   = "0".."1" | "_"
bin-prefix  = "0b" | "0b"
bin-literal = bin-prefix {bin-digit}

oct-digit   = "0".."7" | "_"
oct-prefix  = "0o" | "0O"
oct-literal = oct-prefix {oct-digit}

dec-start   = "0".."9"
dec-digit   = "0".."9" | "_"
dec-prefix  = "0d" | "0D"
dec-literal = (dec-prefix | dec-start) {dec-digit}

hex-digit   = "0".."9" | "a".."f" | "A".."F" | "_"
hex-prefix  = "0x" | "0X"
hex-literal = hex-prefix {hex-digit}

int-literal = bin-literal | oct-literal | dec-literal | hex-literal
</code></pre><h4>1.3.5. Floating-point number literals</h4><p>The fractional and decimal numbers are stored according to "IEEE754 Floating point number standard". The language uses the 64-bit values to represent the values.<p>The floating point literals are <strong>required</strong> to contain the <code>"."</code> (dot) symbol. In general, the floating point literal can be represented as<pre><code>[prefix] &LTwhole digits> . &LTfractional digits> [(E|P) [+|-] &LTexponent digits>]
</code></pre><p>It is <strong>required</strong> to have at least one whole digit, one fractional digit, and if the exponent part exists, one exponent digit. This requirement is not satisfied, as in <code>1.e+1</code>, the compiler throws an error.<p>The compiler only supports two flavors of the floating-point numbers: decimal floating point numbers, and hex floating-point numbers. The hex floating-point literals are prefixed with <code>0x</code> or <code>0X</code>, the decimal floating-point literals are <em>optionally</em> prefixed with <code>0d</code> or <code>0D</code>.<p>In case of decimal floating point numbers, if the fractional digits are followed by <code>"e"</code> or <code>"E"</code> symbol, the exponent digits specify decimal exponent, where the value of the literal is in the form:<pre><code class=language-x>value = (whole.fraction) * 10^exponent
</code></pre><p>Also the so-called scientific notation.<p>In case of binary floating-point numbers, if the fractional digits are followed by <code>"p"</code> or <code>"P"</code>, the exponent digits specify binary exponent. And the value of the literal is in the form:<pre><code class=language-x>value = (whole.fraction) * 2^exponent
</code></pre><p>If the value is in the subnormal range, or exceeds the 64-bit floating-point maximum value, then compiler throws an error.<p>The formal syntax is as follows:<pre><code class=language-ebnf>dec-prefix = "0d" | "0D"
dec-start  = "0".."9"
dec-digit  = "0".."9" | "_"
dec-whole  = (dec-prefix | dec-start) {dec-digit}
dec-fract  = {dec-digit}
dec-exp    = {dec-digit}
dec-float  = dec-whole "." dec-fract [("e" | "E") ["+" | "-"] dec-exp]

hex-prefix = "0x" | "0X"
hex-digit  = "0".."9" | "a".."f" | "A".."F" | "_"
hex-whole  = hex-prefix {hex-digit}
hex-fract  = {hex-digit}
hex-exp    = {hex-digit}
hex-float  = hex-whole "." hex-fract [("p" | "P") ["+"|"-"] hex-exp]

float-literal = dec-float | hex-float
</code></pre><p>Some examples:<pre><code class=language-x>2.0E+1   # valid, parsed as 20.0
0x2.0E-1 # valid, parsed as (2.0 * 2^-1), or 1.0
2E+1     # invalid, doesn't contain "." symbol
2.0p+1   # invalid, binary exponent in decimal value
0x2.0e-1 # invalid, decimal exponent in hex value
</code></pre><h4>1.3.6. Character literals</h4><p>Character literals represent unicode codepoints. They can be given either by giving character directly, or by providing an escape sequence.<pre><code class=language-ebnf>apostrophe  = "\u+2d"
backslash   = "\u+5c"
char-symbol = "\u+01".."\u+2c" | "\u+2e".."\u+5b" | "\u+5d".."\u+10ffff"

char-literal = apostrophe (char-symbol | escape-sequence) apostrophe
</code></pre><p>Some examples of character literals:<pre><code class=language-x>'a'       # valid, maps to u+61
'я'       # valid, contains a Unicode character
'\''      # valid, maps to "'" (apostrophe) character
'"'       # valid, maps to '"' (quote mark) character
'\"'      # also valid, maps to '"' (quote mark) character
'\'       # invalid, the character literal isn't closed
''        # invalid, the character literal is empty
'\u11000' # invalid, the literal specifies character out of the Unicode range
</code></pre><h4>1.3.7. String literals</h4><p>String literals represent Unicode strings of text. The strings can contain any Unicode characters (including some control characters, like line feed)<pre><code class=language-ebnf>quote-mark  = "\u+22"
backslash   = "\u+5c"
str-symbol  = "\u+01".."\u+21" | "\u+23".."\u+5b" | "\u+5d".."\u+10ffff"

str-literal = quote-mark {str-symbol | escape-sequence} quote-mark
</code></pre><p>The examples of valid and invalid strings:<pre><code class=language-x>"abcdef" # valid
"абвгед" # valid

"
hey
"        # valid, contains "\nhey\n"

"#"      # valid, contains the "#" character
</code></pre><h4>1.3.8. Identifiers</h4><p>Identifiers represent user-defined names and <em>keywords</em>. The identifiers may only contain ASCII letters, underscores and digits. However identifiers are not allowed to start with a digit.<p>The formal syntax:<pre><code class=language-ebnf>identifier-start = "_" | "a".."z" | "A".."Z"
identifier-char  = "_" | "a".."z" | "A".."Z" | "0".."9"
identifier       = identifier-start {identifier-char}
</code></pre><p>Some valid and invalid identifiers:<pre><code class=language-x>cat    # valid
_cat__ # valid
d012   # valid
0d10   # invalid, starts with digit
a\ts   # invalid, can not contain backslash
жаба   # invalid, can not contain non-ascii characters
</code></pre><h4>1.3.9 Special symbols</h4><p>A special set of character sequences is used for special symbols such as operators. For example <code>+=</code> is not plus operator followed by the equals operator, it is a single operator. The compiler must match the longest operator from this sequence before advancing parsing to the next lexeme.<pre><code class=language-x>+   +=   ~   ~=   $   <    &LT-   (    )
-   -=   |   |=   @   >    ->   [    ]
*   *=   &   &=   !   <=   ,    {    }
/   /=   <<  <<=  ?   >=   .    ;
%   %=   >>  >>=  ==  !=   :    ..
</code></pre><h3>1.4 Keywords</h3><p>Keywords are special types of identifiers whose usage is reserved for special occasions. User can not declare a variable or a type with the keyword name.<p>The list of keywords and their meaning is listed before<table><thead><tr><th align=left>keyword<th align=left>meaning<tbody><tr><td align=left><code>null</code><td align=left>the null-pointer<tr><td align=left><code>false</code><td align=left>boolean false<tr><td align=left><code>true</code><td align=left>boolean true<tr><td align=left><code>nan</code><td align=left>floating point NaN value<tr><td align=left><code>inf</code><td align=left>floating point infinity value<tr><td align=left><code>bool</code><td align=left>boolean type name<tr><td align=left><code>char</code><td align=left>32-bit integer type name<tr><td align=left><code>int</code><td align=left>64-bit integer type name<tr><td align=left><code>byte</code><td align=left>8-bit integer type name<tr><td align=left><code>float</code><td align=left>floating-point type name<tr><td align=left><code>ptr</code><td align=left>untyped pointer type name<tr><td align=left><code>and</code><td align=left>boolean and operation<tr><td align=left><code>or</code><td align=left>boolean or operation<tr><td align=left><code>xor</code><td align=left>boolean xor operation<tr><td align=left><code>iff</code><td align=left>boolean equivalence operation<tr><td align=left><code>implies</code><td align=left>boolean implication operation<tr><td align=left><code>not</code><td align=left>boolean negation operation<tr><td align=left><code>sizeof</code><td align=left>sizeof operation<tr><td align=left><code>if</code><td align=left><strong>if</strong> statement's starting lexeme<tr><td align=left><code>else</code><td align=left>else branch of the <strong>if</strong> statement<tr><td align=left><code>while</code><td align=left><strong>while</strong> statement's starting lexeme<tr><td align=left><code>do</code><td align=left><strong>do</strong> part of the do-until statement<tr><td align=left><code>until</code><td align=left><strong>until</strong> part of the do-until statement<tr><td align=left><code>try</code><td align=left><strong>try</strong> in the try-catch block<tr><td align=left><code>catch</code><td align=left><strong>catch</strong> in the try-catch block<tr><td align=left><code>let</code><td align=left>variable declaration starting lexeme<tr><td align=left><code>type</code><td align=left>type declaration starting lexeme<tr><td align=left><code>func</code><td align=left>func declaration starting lexeme and func type name<tr><td align=left><code>meth</code><td align=left>method declaration inside structs<tr><td align=left><code>this</code><td align=left>encapsulated struct pointer<tr><td align=left><code>operator</code><td align=left>operator declaration inside structs<tr><td align=left><code>struct</code><td align=left><strong>struct</strong> declaration starting lexeme and struct type name<tr><td align=left><code>enum</code><td align=left><strong>enum</strong> declaration starting lexeme and enum type name<tr><td align=left><code>union</code><td align=left><strong>union</strong> declaration starting lexeme and union type name<tr><td align=left><code>print</code><td align=left>print statement's starting lexeme<tr><td align=left><code>assert</code><td align=left>assert statement's starting lexeme<tr><td align=left><code>break</code><td align=left>break statement<tr><td align=left><code>continue</code><td align=left>continue statement<tr><td align=left><code>return</code><td align=left>return statement<tr><td align=left><code>throw</code><td align=left>throw statement<tr><td align=left><code>import</code><td align=left>import file<tr><td align=left><code>namespace</code><td align=left>namespace scope</table><h2>2. Code structure</h2><p>This section covers the structure of the <strong>X</strong> code, starting down from the expressions syntax and ending with the most top-level syntax.<p>This section only covers the syntax of the parts of the code but does not give any explanation to their semantics and use-cases.<h3>2.1. Expressions</h3><p>Expressions are representations of simple computations being performed on values.<h4>2.1.1. Literal expressions</h4><p>The literal expressions, or the value-expressions are the simplest expressions consisting of a simple value.<pre><code>litexpr = int-literal 
        | float-literal
        | char-literal
        | string-literal
        | identifier
</code></pre><h4>2.1.2. Operators</h4><h3>2.2. Types</h3><h3>2.3. Statements</h3><h3>2.4. Code structure</h3><p>The source code structure of <strong>X</strong> represets a list of statements. Whenever the <strong>X</strong> program is compiled and then executed, conceptually the execution starts from the very first statement of the program. Unlike most other procedural and object-oriented programming languages, <strong>X</strong> does not require an execution entry point.<h2>3. Type system.</h2><p>Type system is a special system inside a compiler that is meant for <em>prevention of logical errors</em> in the code. The typing discipline in <strong>X</strong> is <strong>static</strong>, meaning that all checks are done during the compilation, and not during the execution of the program, and <strong>strict</strong>, meaning that there is no implicit type conversions (except couple special cases).<p>Type is a special property of a value, that determines:<ul><li>The operations available on the value<li>The size of the value</ul><p>This section provides a set of definitions for the types used in this language, their relationships and groups of types used to determine which operations are available.<h3>3.1. Types and type categories</h3><h4>3.1.1. Primitive types</h4><p>X language supports the following primitive types:<table><thead><tr><th align=left>type<th align=left>size<th align=left>set of values<tbody><tr><td align=left><code>bool</code><td align=left>1<td align=left><code>false</code>, <code>true</code><tr><td align=left><code>byte</code><td align=left>1<td align=left><code>-2^7 .. 2^7-1</code><tr><td align=left><code>char</code><td align=left>4<td align=left><code>-2^31 .. 2^31-1</code><tr><td align=left><code>int</code><td align=left>8<td align=left><code>-2^63 .. 2^63-1</code><tr><td align=left><code>float</code><td align=left>8<td align=left>Set of all IEEE754 64-bit representable floating-point numbers<tr><td align=left><code>ptr</code><td align=left>8<td align=left><code>-2^63 .. 2^63-1</code></table><p>The syntax for primitive types is:<pre><code class=language-ebnf>prim-type = "bool"
          | "byte"
          | "char"
          | "int"
          | "float"
          | "ptr"

prim-or-alias = prim-type | identifier
</code></pre><p>The type aliases are just identifiers declared to mean some other type. They are <strong>not</strong> distinct types.<h4>3.1.2. Typed pointer</h4><p>Typed pointers are the same size as the <strong>pointer</strong> types. However typed pointers preserve the information about the type of the value it points to.<p>The syntax for the typed pointer is:<pre><code class=language-ebnf>
ptr-type = type "$" 
</code></pre><p>For example, the type "pointer to int" is written as follows:<pre><code class=language-x>int$
</code></pre><p>The <em>typed pointer</em> will be referred to as <strong>a pointer</strong>, and the primitive pointers from the previous sections will be referred to as <strong>untyped pointers</strong>.<h4>3.1.3. Slice types</h4><p>Slice types represent contiguous memory blocks. The values of slice-types can be thought of as pointer to the start of the block plus the size of the block.<p>Making slice of functions is illegal, since function's size is undefined (see <strong>p.3.1.4.</strong>). One can, however, make a slice of pointers of functions.<p>The syntax for the slice types is as follows:<pre><code class=language-ebnf>slice-type = type "[]"
</code></pre><p>Some examples of slices:<pre><code class=language-x>byte[]    # legal, a slice of bytes
func()[]  # illegal
func()$[] # legal, a slice of pointers to funcs
</code></pre><h4>3.1.4. Function types</h4><p>Functions represent code that can be run with certain parameters and that can return a certain value. Thus function types encompass the types of the function parameters and the type of the return value of the function.<p>Values of function types have <strong>undefined size</strong>. The <code>sizeof</code> operator should return <code>-1</code> for every value of function type or the function type itslef. This also means you can not use function type to declare:<ul><li>Struct fields<li>Variables<li>Function parameters</ul><p>However the <strong>pointers to functions</strong> have similar semantics as functions and can be used instead.<p>The name of any of the parameters <strong>can not be a keyword</strong>. The parameters can not have a function type.<p>The syntax is as follows:<pre><code class=language-ebnf>sep          = "," | ";"

iden-list    = identifier {sep identifier}
func-param   = iden-list ":" type
func-params  = func-param {sep func-param}

func-mapping = "(" [func-params] ")" ["->" simple-type]
func-type    = "func" func-mapping
</code></pre><p>Some examples of function types:<pre><code class=language-x># function taking no parameters and returning nothing
func()

# function taking no parameters and returning an int
func()->int

# function taking two first int parameter and second float parameter
# and not returning a value
func(a: int, b: float)

# same as above, uses semicolon for separator
func(a: int; b: float)

# function taking one parameter of type
#   (pointer to function taking int, returning an int)
# and returning an int
func(a: (func(a: int)->int)$ )->int

# invalid, parameter can't be a function type
func(a: func())->int

# function taking 3 ints and 1 float, and 1 bool
# note the different separators
func(x,y;z:int, a:float; b: bool)
</code></pre><h4>3.1.5. Struct types</h4><p><strong>Struct types</strong> represent groups of values stored together as a single unit of data. In pascal, also known as the <strong>record types</strong>.<p>In <strong>X</strong> struct types, can also contain <em>functions</em> and <em>methods</em>.<p><strong>Field declarations</strong> can not declare fields of function types (<strong>p.2.1.4</strong>), since the values of function type have <em>undefined</em> size. They can, however contain functions themselves.<p>If the struct type is declared via <code>type</code> declaration or <code>struct</code> declaration, none of the fields can directly contain field of the type being declared. Simply speaking, some recursive types are not allowed. However, the fields can take the type of e.g. "pointer to type" or "slice of type", since the size of pointer and slice is known.<p>Declarations in struct fields are be <strong>separated</strong> by either <code>","</code> (comma) or <code>";"</code> (semicolon). The function and method declarations inside structs may not be followed by the separator. All <em>field</em> declarations, except if it is the last in the struct to be terminated by either <code>","</code> or <code>";"</code>.<p>The order of the fields is the same as the order of the identifiers. <code>a,b,c: int, d: float</code> has the same order of fields as <code>a:int, b:int, c:int, d:float</code>. The compiler <strong>can not reorder fields</strong>.<p>The syntax for the struct fields is:<pre><code class=language-ebnf>sep          = ";" | ","

iden-list    = identifier {sep identifier}
struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier ":" func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier ":" func-mapping "{" stmt-list "}" [sep]

struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl

struct-type  = "struct" "{" struct-decls "}"
</code></pre><p>Here are some examples of structs:<pre><code class=language-x># C-like separation of fields
struct {
  a: int;
  b: float;
}

# Inline style
struct {a:int, b:float}

# Same as above, with trailing comma
struct {a:int, b:float,}

# Struct with packed decls, function and method
struct {
  x,y;z: int;
  c:float,

  func add: (a,b: int)->int {
    return a+b;
  }

  meth neg: () {
    x = -x;
    y = -y;
    z = -z;
  };
}

# valid, structs can contain pointer to functions as fields
struct {
  f: (func()->int)$;
}

# invalid, structs can not contain function fields
struct {
  f: func()->int;
}

# invalid, structs have to have at least one decl
struct {}
</code></pre><h4>3.1.6. Union types</h4><p><strong>TODO</strong><h4>3.1.7. Enum types</h4><p><strong>TODO</strong><h4>3.1.8. The syntax for types</h4><p>In the previous sections all the types of the <strong>X</strong> have been shown, however the formal grammar had left-recursion because that way it was the easiest to understand.<p>The complete syntax for the types in <strong>X</strong> is presented below. All of the left-recursions have been removed.<pre><code class=language-ebnf>prim-type    = "bool"
             | "byte"
             | "char"
             | "int"
             | "float"
             | "ptr"
alias-type   = identifier

sep          = ";" | ","
iden-list    = identifier {sep identifier}

func-param   = iden-list ":" type
func-params  = func-param {sep func-param}
func-mapping = "(" [func-params] ")" ["->" simple-type]
func-type    = "func" func-mapping

struct-field = iden-list ":" type sep
last-field   = iden-list ":" type [sep]
struct-func  = "func" identifier ":" func-mapping "{" stmt-list "}" [sep]
struct-meth  = "meth" identifier ":" func-mapping "{" stmt-list "}" [sep]
struct-decl  = struct-field | struct-func | struct-meth
last-decl    = last-field   | struct-func | struct-meth
struct-decls = { struct-decl } last-decl
struct-type  = "struct" "{" struct-decls "}"

base-type    = prim-type | alias-type | struct-type | "(" type ")" 
simple-type  = base-type {"$" | "[]"}

type         = simple-type | func-type {"$" | "[]"}
</code></pre><h3>3.2. Type relationships and operations</h3><h4>3.2.1. Equivalence</h4><p>The equivalence defines relationship of types as being "the same" in the sense that is transparent to how they are defined. For example <code>int</code> and any type alias to <code>int</code> are equivalent, because they refer to the same type - <code>int</code>.<p>Types <strong>T</strong> and <strong>U</strong> are called <strong>equivalent</strong>, if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are <em>pointers</em> (typed) or <em>slices</em>, and their base types are <strong>equivalent</strong><li><strong>T</strong> and <strong>U</strong> are <em>functions</em> and all of the following is true: <ul><li><strong>T</strong> and <strong>U</strong> have <strong>equivalent</strong> return types<li><strong>T</strong> and <strong>U</strong> have the same number of parameters<li>For every parameter of <strong>T</strong>, and the corresponding parameter of <strong>U</strong>, they have <strong>equivalent</strong> types</ul><li><strong>T</strong> and <strong>U</strong> are <em>structs</em> and all of the following is true: <ul><li><strong>T</strong> and <strong>U</strong> have the same number of fields<li>For every field of <strong>T</strong>, and the corresponding field of <strong>U</strong>, they have <strong>equivalent</strong> types and same name.</ul><li><strong>T</strong> and <strong>U</strong> are primitive types and <strong>T</strong> = <strong>U</strong>.</ol><p>If none of the above is true, then <strong>T</strong> and <strong>U</strong> are <strong>not equivalent</strong>.<p>As a consequence of the definition the following applies:<ol><li>Any type <strong>T</strong> is equivalent to itself<li>If <strong>T</strong> and <strong>U</strong> are equivalent, then <strong>U</strong> and <strong>T</strong> are equivalent.<li>If <strong>T</strong> and <strong>U</strong> are equivalent, and <strong>U</strong> and <strong>V</strong> are equivalent, then <strong>T</strong> and <strong>V</strong> are equivalent.</ol><p>Note that structs are equivalent only if the fields are equivalent. Any two structs with the same fields but different functions inside them are also equivalent.<h4>3.2.2. Assignability</h4><p>The type <strong>T</strong> is <strong>assignable</strong> to <strong>U</strong> if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are <strong>equivalent</strong><li><strong>T</strong> is <em>pointer</em> and <strong>U</strong> is untyped <code>ptr</code><li><strong>U</strong> is <em>pointer</em> and <strong>T</strong> is untyped <code>ptr</code></ol><p>Otherwise <strong>T</strong> is <strong>not assignable</strong> to <strong>U</strong>.<p>As a consequence,<ol><li>Any type <strong>T</strong> is assignable to itself<li>If <strong>T</strong> is assignable to <strong>U</strong>, then <strong>U</strong> is assignable to <strong>T</strong>.<li>If <strong>T</strong> is assignable to <strong>U</strong>, and <strong>U</strong> is assignable to <strong>V</strong>, then <strong>T</strong> is assignable to <strong>V</strong>.</ol><h4>3.2.3. Castability</h4><p>The castability determines whether values of one type can be cast, i.e. converted to another type. Castability does an explicit conversion, preserving the meaning.<p>Type <strong>T</strong> is <strong>castable</strong> to type <strong>U</strong> if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are same or different primitive types (<code>bool</code>, <code>byte</code>, <code>int</code>, <code>char</code>, <code>float</code>, <code>ptr</code>)<li><strong>T</strong> and <strong>U</strong> are <em>pointers</em> of any underlying types (including untyped <code>ptr</code>).<li><strong>T</strong> and <strong>U</strong> are <em>slices</em> of any underlying types.<li><strong>T</strong> and <strong>U</strong> are <em>structs</em> with all of the following holds: <ul><li><strong>T</strong> and <strong>U</strong> have the same number of fields<li>corresponding fields's types of <strong>T</strong> and <strong>U</strong> are <strong>assignable</strong></ul><li><strong>T</strong> and <strong>U</strong> are <em>functions</em> and all of the following holds: <ul><li><strong>T</strong> and <strong>U</strong> have the same number of parameters<li>corresponding parameters's types of <strong>T</strong> and <strong>U</strong> are <strong>assignable</strong></ul></ol><p>Otherwise <strong>T</strong> is <strong>not castable</strong> to <strong>U</strong>.<p>The details about the results of the <em>cast</em> operation are discussed later (<strong>p.????</strong>)<h4>3.2.4. Transmutability</h4><p>The transmutability determines whether bit-sequence of one type can be re-interpreted as sequence of bits for another type.<p>Type <strong>T</strong> is <strong>transmutable</strong> to <strong>U</strong> if one of the following is true:<ol><li><strong>T</strong> and <strong>U</strong> are primitives that have the same size. (e.g. <code>int</code> and <code>float</code>)<li><strong>T</strong> is any pointer and <strong>U</strong> is any pointer.<li><strong>T</strong> and <strong>U</strong> are structs types of the same total size.</ol><p>Otherwise <strong>T</strong> is <strong>not transmutable</strong> to <strong>U</strong>.<h3>3.3. Type groups</h3><p>In order to make discussions about operations and expressions easier the <strong>type groups</strong> are introduced in this section. Each operation is specified as acting on types of certain groups. For example the operations of addition, subtraction and multiplication are available for all types of "arithmetic" group. One type can belong to several groups.<h4>3.3.1. Integer arithmetic (IA)</h4><p>This is a group, such that for all values of this group the operations of the whole arithmetic, namely negation, addition, subtraction, multiplication, integer division, modulo division and all bitwise operations are defined.<p>The details of those operations and the acceptable and derived types are not discussed here. However we are going to list the types of the group <strong>IA</strong>:<ul><li><code>byte</code><li><code>char</code><li><code>int</code><li><code>ptr</code><li>All typed pointers</ul><h4>3.3.2. Floating-point arithmetic (FA)</h4><p>For the values of <strong>FA</strong> group types, the operations of negation, addition, subtraction, multiplication, division and modulo division are defined.<p>The only type of the group <strong>FA</strong> is <code>float</code>. Unlike <strong>IA</strong> group, values of <strong>FA</strong> group types can not access bitwise operations.<h4>3.3.3. Logical (Log)</h4><p>For the values of <strong>Log</strong> group, boolean operations are defined: logical negation, logical and, or, xor, implication and equivalence. The only type of this group is <code>bool</code>.<h4>3.3.4. Ordered (Ord)</h4><p>For the values of <strong>Ord</strong> group types the following operations of relation are defined: less-than, greater-than, not-less (greater-or-equal), not-greater (less-or-equal).<p>The following types have the <strong>Ord</strong> category:<ul><li><code>bool</code><li><code>byte</code><li><code>char</code><li><code>int</code><li><code>float</code><li><code>ptr</code><li>All typed pointers</ul><h4>3.3.5. Subscriptable (Sub)</h4><p>For the values of <strong>Sub</strong> group, the operation of subscripting is available. The types of this group are all the typed pointers and all the slices.<h4>3.3.6. Callable (Call)</h4><p>For the values of <strong>Call</strong> group, the operation of function calling is available. The types of this group are functions, method functions and pointers to functions.<h4>3.3.7. Structure (Str)</h4><p>For the members of <strong>Str</strong> group, the operation of member access is accessible. The types of this group are all the <code>struct</code> types, pointers to structs and any slice types.<p>The details of which particular fields are accessible is described, whenever the member access operation is described.<h2>4. Declarations</h2><p>Declarations introduce name to the vocabulary of a program.<p>In <strong>X</strong> there are several types of declarations.<ul><li>Variable declarations<li>Type declarations<li>Function declarations<li>Struct declarations<li>Method declarations</ul><p>The name introduced by any declaration can not be any of the keywords (<strong>p.1.4</strong>). The <em>shadowing</em> of declarations is <strong>not allowed</strong>.<p>This section describes declarations' syntax, scoping system, visibility in detail.<h3>4.1. Scope system</h3><p>Every element of the language that can contain declarations has it's own <strong>scope</strong> (e.g. function scope). I will refer to the statements or expressions inside those containers as also being <em>inside their scope</em>.<p>Every scope, except the <strong>global</strong> scope has a <strong>parent scope</strong>. If scope <strong>s</strong> belongs to statement <strong>S</strong>, the parent of the scope <strong>s</strong> is the scope, where <strong>S</strong> is located.<pre><code class=language-x># global scope
func a: (x:int) { # function scope
  # block scope
}
</code></pre><p>In the example above you can see three scopes: the global scope, the function scope and the block scope. The block scope is part of the block statement. The block statement is part of the function, so the function scope is the parent of the block scope. Also the function scope is part of the function statement, which is the part of the global block. Therefore the global scope is the parent of the function scope.<p>Every scope has a list of <strong>own</strong> declarations and a list of <strong>inherited</strong> declarations associated with it. The list of own declarations consists of all the declarations within the element with which the scope is associated (except the elements within the elements of the associated element).<p>The list of inherited declaraions specifies the declarations that the scope "sees" in it's parent scope. Of course not all of the declarations are visible. In the following example inside the block scope only the variable <code>x</code> is visible but not <code>y</code>:<pre><code class=language-x>let x: int = 4;
if x&LT10 {
  let z: int = x+y;   #error, y is not visible in this scope
}
let y: int = 4;
</code></pre><p>That's why it's important to specify that scope only inherits those declarations from parent located <em>before</em> it. What the word before means depends on the context, but in general it literally means "occuring earlier in the source". One exception is the variable declaration expression's scope:<pre><code class=language-x>let x: int = x~x;    # error, x is not visible in the initializer of x
</code></pre><p>However the function declarations are inherited without that requirement. Therefore the following code is valid:<pre><code class=language-x>{
  add(2,3);  # valid, even though it is located "after" this block scope
}

And the struct declarations allow their name to be 

func add: (x,y: int)->int {
  return x+y;
}
</code></pre><p>Based on the kind of the element, where the declarations are located, the scope have distinct kinds:<ul><li>Block scope. Every statement block has it's own scope.<li>While scope (applied to <code>while</code> statements)<li>If scope (applied to <code>if</code> statements)<li>Function scope (applied to methods and functions)<li>Struct scope (applied to <code>struct</code> declarations)</ul><h4>4.1.1. Basic relationships</h4><p>The scope <strong>P</strong> is an <strong>ancestor</strong> of <strong>S</strong> if one of the following applies:<ul><li><strong>P</strong> is a parent of <strong>S</strong><li><strong>P</strong> is a parent of an <strong>ancestor</strong> of <strong>S</strong></ul><p>If scope <strong>S</strong> has parent <strong>P</strong>, then <strong>P</strong> has <strong>child</strong> <strong>S</strong>.<p>The scope <strong>S</strong> is <strong>descendant</strong> of <strong>P</strong> if one of the following applies:<ul><li><strong>S</strong> is a child of <strong>P</strong><li><strong>S</strong> is a child of <strong>descendant</strong> of <strong>P</strong></ul><p>You can think of an <em>ancestor</em> as being a enclosing scope enclosing <strong>S</strong> and <em>descendant</em> scope as being "inside" of <strong>P</strong>.<p>In order define accessibility and visibility we will define an addition notion of declaration being located "before" another declaration or the scope. The phrase <strong>before X</strong> means either before <strong>X</strong> in the current scope, or before any of the ancestor scopes of <strong>X</strong>.<h4>4.1.2. Visibility</h4><p>Scope <strong>S</strong> is said to <strong>inherit</strong> declaration <strong>D</strong> from the parent scope <strong>P</strong> if the following conditions are met:<ul><li><strong>D</strong> is in <strong>P</strong><li><strong>D</strong> is located <strong>before</strong> <strong>S</strong><li>When <strong>S</strong> is a struct or function scope, <strong>D</strong> is a type declaration</ul><p>In scope <strong>S</strong> declaration <strong>D</strong> is called <strong>visible</strong> if one of the following is true:<ul><li><strong>D</strong> is in <strong>S</strong><li><strong>S</strong> inherits <strong>D</strong> from its parent <strong>P</strong>, and <strong>D</strong> is <strong>visible</strong> in <strong>P</strong></ul><p>A declaration <strong>D</strong> is called <strong>accessible</strong> from statement or scope <strong>s</strong> if the following conditions are met:<ul><li><strong>D</strong> is visible from the scope of <strong>S</strong><li><strong>D</strong> is located before <strong>s</strong><li><strong>S</strong> inherits <strong>D</strong> from <strong>P</strong></ul><h4>4.1.1. Shadowing</h4><p><strong>Shadowing</strong> is considered to occur whenever to or more distinct declarations are <strong>accessible</strong> from some scope.<p>If any declaration <strong>D</strong> shadows any declaration <strong>d</strong>, the compiler throws an error.