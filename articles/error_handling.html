<!DOCTYPE html><html><head><meta charset=utf-8><meta name=referrer content=no-referrer><meta name=viewport content="width=device-width, initial-scale=0.7"><link rel=stylesheet href=/styles.css><link rel=favicon href=/favicon.ico><link rel=apple-touch-icon href=/favicon.ico><script src=/coloring.js defer></script><body><h1>How to handle errors in your code and think about errors correctly</h1><p>Publication date: 2021-03-31<p><strong>"How do I handle errors when writing a program"</strong> is probably one of the first questions a beginner could ask after successifully learning about control flow operators and being able to write medium-sized programs.<p>The reason I'm writing this post is to help such beginners to think clearly when it comes to implementing error checking and handling.<p>In order to read this article the requirements are the knowledge about control flow operators and the knowledge of any C-like language. You're also are required to know about debug and release builds. I will be writing pseudo-C code in an imaginary language, I hope that you are experienced enough to adapt to some trivial syntactic differences.<p>It is very easy for a beginner to go the wrong road trying to handle errors. Most of the reasons come from the fact that beginners not knowing what errors are assume they do, and implement the same things they see in their everyday experience: message boxes with errors, error screens, etc., without consideration of other factors that affect realiability of a program, helpfulness of error messages and so on.<p>This article presents with a definition of what an error is, what are the essential properties of errors and finally how to handle the errors correctly by thinking about those properties, that is a certain <em>philosophy of error handling</em>.<p>By the end of reading this article you will be able to identify the errorneus states in your code, analyze them and finally be able to correctly handle them.<h2>The problem</h2><p>How does a program that doesn't handle errors look like? If you programmed in a language like <strong>C</strong> you're more likely to understand how the program without error handling looks like. It is very unforgiving and crashy. Invalid input will crash the program silently, and if not produce incorrect result. Division by zero will crash your program, and accessing memory outside of "arrays" will cause reading garbage.<p>Suppose a user launches a simple program called "divider" that takes two inputs and divides first number by the second, then prints the result.<pre><code>program1:
 a = get_number();
 b = get_number();
 print(a / b);
</code></pre><p>In the <em>program1</em>, if you run the program and input <code>0</code> as the value for <code>b</code>, the program will silently crash. Of course, this should not happen.<p>In languages like <strong>Java</strong>, when you divide by zero, by default the program prints exception's stack trace and a very ugly error message. The error is reported by default, but the <em>way</em> in which it is reported is very unhelpful to a general user:<pre><code>Exception in thread "main" java.lang.ArithmeticException: / by zero  
  at Class.main([Class.java](Class.java):3)
</code></pre><p>So the correct error handling is the one that always <em>prints the correct output</em>. This means that when expression can be computed the expression value is printed, and when expression can not be computed the <em>reason why</em> is printed. The algorithm looks like this:<pre><code>program2:
 a = get_number();
 b = get_number();
 if b != 0 {
   print(a / b);
 }
 else {
   print("undefined");
 }
</code></pre><p>The craft of error handling is to make sure that unexpected data inputs from the user are reported back to the user.<p>The control flow break is part of what defines the error. That is, error checking and handling requires more code to be written. That's why in writing bigger programs it is important to free your mind of problems by writing a program that handles <em>the most common case</em> first, and only then extend it by adding error checking facilities.<p>The error reporting can get more complex. For example in my compiler (I'm writing one), in a parser, if there is anything incorrect about the structure of a program, for example an unknown operator is inserted between two expressions, instead of shutting down on error, my parser will print the error message and then continue parsing statements starting from the next semicolon.<p>The reason I made that decision is because when user compiles his code, typically there is more than one error. If I was to shut down the parser immediately after the first error, the user will have to go through the cycle (fix the error -> recompile -> ...).<p>That's why it is not only important to make sure the error message is printed correctly, but also to make sure the error reporting mechanism is useful to the user, in that they can fix the errors.<p>However not everything is about <em>doing</em> error handling. Sometimes it is useful to <em>avoid</em> error handling. The reason to avoid doing error reporting might be that the source of the error is not a user/user's machine, but rather <em>the programmer</em>.<p>Imagine that you're writing a game that has thousands of sprites of resolution about (500x500) and as a developer you don't care about the modifications the players make to the game. That effectively makes sprites "programmer-provided data".<pre><code>for every image {
  for every pixel in image {
    if pixel is invalid {
       print_error(image.path + " could not be loaded");
       crash();
    }
  }
}
</code></pre><p>In order to check the validity of the sprite data you'd have to check 1000x500x500 pixels in total (about 250 million pixels). This can have significant performance impacts on the application. For the user that data <em>never changes</em>, so those computations are effectively wasted!<p>In programming there is mechanism that allows erorr checking during testing but disables it in release builds. It is called "an assertion". The basic principle is that in <strong>debug builds</strong>, <code>assert</code> computes the expression inside it, and if expression evaluates to <code>true</code> the program continues it's execution. If expression evaluates to <code>false</code>, the error message is printed and the program is crashed. In <strong>release builds</strong> asserts <em>do nothing</em>, since they are removed by the compiler.<p>Note that crash of the program on assert is <strong>not</strong> something you should handle. The whole point is that assertions <em>have</em> to hold true during program execution.<p>The pseudocode from earlier can be replaced with the following code:<pre><code>for every image {
  for every pixel in image {
    assert pixel is valid;
  }
}
</code></pre><p>The difference is that (1) we aren't printing the error message to the user, because if the game data is wrong, there's nothing the user can do about it except reinstall the game (2) we're able to detect the error as a programmer, but in release builds <code>assert</code> will be removed, and since <code>assert</code> is removed, the two loops do "nothing", and any decent optimizing compiler will have no problem optimizing out empty loops.<p>From the previous chapter it follows that you should <em>not</em> use <code>assert</code> to check for the user input. The errors in the user input should be checked in release builds, not only in debug builds, since the users will be using the release build!<p>The purpose of this section is to establish certain properties of our program that are affected by the error handling. Those properties are:<ul><li>Robustness - ability of the program to continue execution after an invalid state and finish it's execution correctly for wider range of possible inputs.<li>Usefulness - how useful the error report is to the person receiving it, so that they can fix the data they provide to the program.<li>Directness - the program doesn't waste computation time computing for the case that never happens.</ul><h2>Definitions</h2><p>In order to make sure that our thinking about the problem is correct we need to establish the scope of what situations we're talking about.<p><strong>Error</strong> (error state) - any kind of state in the process of the program's execution that was caused by any invalid data preventing the program from computing a valid solution to a given problem.<p>The <em>invalid data</em> may be an actual data, like program parameter, or the file that we are processing, however it can also be something in the code, like function parameter or incorrect algorithms as a whole.<p>That implies that making an off-by-one mistake in an algorithm is an error that may or may not be handled. Passing wrong number of parameters to a program is also an error. All of the examples prevent program from computing valid solution. Those examples check out with our definition.<p><strong>Error handling</strong> - behaviour of the program on <em>error</em> and the process of describing that behaviour in a program.<p>That means "what the program does", when an error occurs and "the process of programming this behaviour" in our program. This behaviour can be one of the following:<ul><li>Doing nothing (continue executing invalid code)<li>Crash<li>Print an error message<li>Compute alternative solution</ul><p>If you are expecting to turn "error" into a "non-error", than that is impossible without making your program wrong. If the data provided by the user is incorrect it is incorrect and you can not (and should not try to) do anything about it.<p>If for example you're running a search for files in directory and the library returns you error "not found", then the directory may trivially be empty. There's nothing wrong with directories being empty.<p><strong>Error message</strong> - any program output, including graphical output meant for notifying the user that an error has occured and providing additional information helping to fix the error.<p>The difference between <em>error</em> and the <em>error message</em> is that <em>error</em> is an internal state of the program, while the <em>error message</em> is what the user sees.<p>Preventing error message from appearing is not the same as preventing errors from appearing. That's why in debug code it is important to properly test that <code>assert</code> never get fired, without disabling them.<p>Furthermore the data can be provided by either <em>the user</em> or <em>the programmer</em>. As discussed earlier, the messages should be appropriate in the information they provide and the messages should be checked appropriately.<p>As in the one of the very first examples of this article, the one about checking images, the rule is simple: if the data is provided by the programming use <code>assert</code>, if the data is provided by the user use <code>if</code> + message report.<p>Internal assumptions about the code and algorithms should be checked using <code>assert</code> statements. The program has no right to exist if it fails on assert. Assert is for fixing fundamental problems within the program.<p>For example if you allocate some memory in <strong>C</strong>, you might call <code>malloc</code>, a function for <em>memory allocation</em>. This function has failing message: if the function has failed to allocate the memory, it will return <code>NULL</code>. You can either assume that the user has infinite memory, which is most likely not the case or you can kindly display "out of memory" message to the user. For demonstration purposes let's assume you decided to go with the option of assuming everyone has infinite memory. Then error checking will look like this:<pre><code>int *ptr = malloc(4);
assert(ptr != NULL);

ptr[0] = 2;
</code></pre><p>This kind of code may be unsafe. It is strongly discouraged, since malloc returning <code>NULL</code> is very real in some cases.<p>Please read about the applications of <em>assert</em> further if you're still unsure about why it should be used. But at least remember this: <code>assert</code> is used for checking <em>assumptions about the workings of the other parts of the program</em>. They are very useful when making changes to your program.<h2>The basic principles</h2><p>Based on the definitions above and all the intuition we have gained from the numerous mini examples we will form the principles of error handling.<h3>1. Always test your code.</h3><p>A good-tested program satisfies the following criteria:<ul><li>When correct data is input, a correct output is computed.<li>When incorrect data is input, some error message is displayed.</ul><p>It's important that you test your program on both kinds of input. The correctness is determined by how it reacts to the first type of input. The reliability of program is determined only by how it reacts to the second type of input.<p>Your program should <strong>never</strong> crash on assert. If it does you should probably fix it immediately.<h3>2. Use appropriate error-reporting mechanism.</h3><p>Don't use <code>if</code> for handling assumptions about the validity of the code. Don't use <code>assert</code> for user input. The first one affects the performance of the program and it's readability, the second one affects it's correctness.<pre><code>assert validate_user_input();
</code></pre><p>Is wrong because in <strong>release build</strong>, the function will be compiled out. That implies that whatever this function normally does will not be done and the user input will remain unhandled.<h3>3. Error messages should help one fix the error.</h3><p>This is about error message contents. The errors should<ol><li>Relate to the user input.<li>Tell what <em>exactly</em> is wrong with the input.</ol><pre><code>Fatal error 0xc0000005
</code></pre><p>Meets none of the criteria. You have no idea what's wrong nor how to fix it.<pre><code>Parser error: could not parse arguments
</code></pre><p>Relates to the user input, but doesn't tell what exactly is wrong. I could skim through the <em>arguments</em> I'm passing, and even may notice what's wrong. The error message has to be better.<pre><code>Parser error: expected number at argument 2.
</code></pre><p>Good. I know <em>where</em> the error happens, <em>what</em> the error is. Then I could go, verify <em>argument 2</em>, to check whether it is really a number or not.<h3>4. Your library can not and should not handle the errors for you.</h3><p>The library that "handles" errors for you is probably not a good library or you are a lazy programmer that doesn't handle it instead. Library should not take the liberty of what error message means what. You as a programmer have the best control over the program input and <em>you</em> should be in charge of specifying how that input is wrong.<h2>Examples</h2><p>Let's take an expression calculator app and add error handling. Error checking is trivial and will not be covered here. This is the code:<pre><code>func calculate_button_hit(string expression) {
  float result = calculate_expr(expression);
  result_label.set_text(to_string(result));
}
</code></pre><p>This is a simple code and you should be able to read it.<p>As you can see if we type something like <code>1/0</code> the result will either be incorrect or we'll crash. Similarly if we forget to close parenthesis <code>1+(2*3</code>, or just write something nonsensical <code>aaaa</code>.<p>Let us rewrite <code>calculate_expr</code> function so that it returns not only the result but also the code that tells us which kind of error has happened.<pre><code>struct calc_result {
  enum {
    RESULT_ok, 
    RESULT_undefined, 
    RESULT_unmatched_paren, 
    RESULT_bad_expr
  } status;
  float value;
};

/* ... */

func calculate_button_hit(string expression) {
  calc_result result = calculate_expr(expression);
  if result.status == RESULT_ok {
    result_label.set_text(to_string(result.value));
  }
}

</code></pre><p>We will only print the the resulting value if the function returned <code>RESULT_ok</code> as it's status value. Now for the errors. All of the errors are definately due to invalid user's input. Therefore we must use <code>if</code> to handle the errors and display helpful error message.<pre><code>if result.status == RESULT_ok {
  result_label.set_text(to_string(result.value));
}
else if result.status == RESULT_undefined {
  result_label.set_text("undefined");
}
else if result.unmatched_paren == RESULT_undefined {
  result_label.set_text("error: parenthesis unmatched");
}
else if result.status == RESULT_bad_expr {
  result_label.set_text("error: invalid expression");
}
</code></pre><p>Note that <code>RESULT_undefined</code> error message wasn't prepended with <code>"error:..."</code> the reason is simple, but subjective. <code>undefined</code> feels like an actual answer to the problem like <code>1/0</code>, whereas the other errors are not computing any sensible result, they are more like "hey I tried to understand what you wrote and it just doesn't make any sense".<p>Finally we can apply everything we have learned in this article and consider another case. What if besides the 4 result states our calculator results something else. This can not possibly happen right? Therefore it counds as an assumption about the working of a program and should be handled using <code>assert</code>.<pre><code>...
else assert false;
</code></pre><p><code>assert false</code> means "crash", since the expression inside it always evaluates to <code>false</code>.<h2>Conclusion</h2><p>You have learned how to identify error states, check for them properly, how to think about the consequences of handling errors in one or another way, of which one is probably "the correct" way.<p>You understand the how to properly chose the error message and what's the purpose behind displaying the error message at all.<p>You are able to add or fix a decent error handling into your program by applying the principles discussed in this article.